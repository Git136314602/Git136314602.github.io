<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Offer=Redis18]]></title>
    <url>%2F2019%2F10%2F09%2FOffer-Redis18%2F</url>
    <content type="text"><![CDATA[剑指Offer-18Redis缓存如何使用Redis做异步队列使用List作为队列，RPUSH生产消息，LPOP消费消息 缺点：没有等待队列里有值就直接消费（为0时，LPOP也可以消费） 弥补：可以通过在应用层引入Sleep机制去调用LPOP重试 BLPOP key [key …] timeout ：阻塞，直到队列有消息或者超时 缺点：只能供一个消费者消费 pub/sub：主题订阅者模式 发送者(pub发送消息，订阅者(sub)接收消息 订阅者可以订阅任意数量的频道 缺点：消息发布是无状态的，无法保证到达 Redis如何做持久化一旦服务器进程退出，数据库数据就会丢失 RDB(快照)持久化：保存某个时间点的全量数据快照 save 900 1/save 300 10/save 60 10000 当900秒内有1条数据存入，做一次备份，其他相似。适应了不同的存储情况，可自定义 。 stop-writes-on-bgsave-error 设置成yes时，备份出错时，主进程停止存入。确保了数据一致性的问题。 SAVE：阻塞Redis的服务器进程，直到RDB文件被创建完毕 BGSAVE：Fork出一个子进程来创建RDB文件，不阻塞服务器进程。 系统调用fork():创建进程，实现了Copy-on-Write Copy-on-Write：一种计算机优化策略，如果有多个调用者同时要求相同资源，他们会共同获取相同的指针指向相同的资源。直到某个调用者试图修改资源时，系统才会复制一个副本给该调用者，其他调用者资源不变 缺点： 内存数据的全量同步，数据量大会由于I/O而严重影响性能。 可能会因为Redis挂掉而丢失从当前至最近一次快照期间的数据。 自动化触发RDB持久化的方式 根据redis.conf配置里的SAVE m n 定时触发(用的是BGSAVE) 主从复制时，主节点自动触发 执行Debug Reload 执行Shutdown且没有开启AOF持久化 AOF（Append-Only-File）持久化：保存写状态 记录下除了查询以外的所有变更数据库状态的指令 以append的形式追加保存到AOF文件中 日志重写解决AOF文件不断增大的问题： 调用fork()，创建一个子进程 子进程把新的AOF写到一个临时文件里，不依赖原来的AOF文件 主进程持续将新的变动同时写到内存和原来的AOF里 主进程获取子进程重写AOF的完成信号 使用新的AOF文件替换掉旧的AOF文件 RDB和AOF文件共存情况下的恢复流程： RDB和AOF的优缺点 RDB优点：全量数据快照，文件小，恢复快 RDB缺点：无法保存最近一次快照之后的数据 AOF优点：可读性高，适合保存增量数据，数据不易丢失 AOF缺点：文件体积大，恢复时间长 RDB-AOF混合持久化方式 GBSAVE做镜像全量持久化，AOF做增量持久化 使用Pipeline的好处 Pipeline和Linux的管道类似 Redis基于请求/响应模型，单个请求处理需要一一应答 Pipeline批量执行指令，节省多次IO往返时间 有顺序依赖的指令建议分批发送 Redis的同步机制全同步过程： Salve发送一个sync命令到Master Master启动一个后台进程，将Redis中的数据快照保存到文件中 Master将保存数据快照期间接收到的写命令缓存起来 Master完成写文件操作后，将该文件发送给Salve 使用新的AOF替换旧的AOF Master将这期间收集的增量写命令发送给Salve端 增量同步过程： Master接收到用户的操作指令，判断是否需要传播到Slave 将操作记录追加到AOF文件 将操作传播到其它Slave：1、对齐主从库；2、往响应缓存写入指令 将缓存中的数据发送给Slave 当Master挂掉后，Salve将不能对外使用写入操作。所以使用Redis Sentinel Redis Sentinel 解决主从同步Master宕机后的主从切换问题： 监控：检查主从服务器是否运行正常 提醒：通过API向管理员或者其他应用程序发送故障通知 自动故障迁移：主从切换 流言协议Gossip 在杂乱无章中寻求一致 每个节点都随机的与对方通信，最终所有节点的状态达成一致 种子节点定期随机向其他节点发送节点列表以及需要传播的消息 不保证信息一定会传递给所有节点，但是最终会趋于一致 Redis的集群原理如何从海量数据块里快速找到所需？ 分片：按照某种规则去划分数据，分散存储在多个节点上 常规的按照哈希划分无法实现节点的动态增减，可能大量的key无法被命中 一致性哈希算法：对2^32取模，将哈希值空间组织成虚拟的圆环 优点：加入NodeC宕机，那么objectC会顺时针存储到最近的服务器中，不会影响其他服务器。 如果在objectC和NodeC之间新增一个NodeX,那么objectC会存到NodeX中，具有较好的容错性和扩展性。]]></content>
      <categories>
        <category>Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Offer-Redis17]]></title>
    <url>%2F2019%2F10%2F09%2FOffer-Redis17%2F</url>
    <content type="text"><![CDATA[剑指Offer-17Redis缓存 客户端查询数据时首先在缓存层查询是否有相关数据，有则直接返回。减轻存储层的压力。 穿透查询就是缓存层中没有，到存储层查询。查询数据后返回称为回种。 熔断是当存储层无法提供服务时，直接让请求在缓存层上，无论是否有数据都直接返回。 缓存中间件-Memcache和Redis的区别Memcache：代码层次类似Hash 支持简单数据类型 不支持数据持久化存储 不支持主从 不支持分片 Redis 数据类型丰富 支持数据磁盘持久化存储 支持主从 支持分片 为什么Redis能这么快（100000+QPS QPS即query per second，每秒内查询次数） 完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高。单线程模型的数据库，由C语言编写，读写的时候都不会受到硬盘IO速度的限制。 数据结构简单，对数据操作也简单。Redis不使用表，也不会跟其他表进行关联，所以简单。 采用单线程，单线程也能处理高并发的请求，想多核也可启动多实例。 使用多路I/O复用模型，非阻塞IO（某一线程因一些原因无法返回，造成阻塞） 多路I/O复用模型 FD：File Descriptor，文件描述符 一个打开的文件通过唯一的描述符进行引用，该描述符是打开文件的元数据到文件本身的映射，用整数表示。 传统的阻塞I/O模型，可能因FD对应的文件不可读或者不可写，而造成堵塞 Select系统调用 用于监听可读或可写文件，收集可读可写的文件描述符的数量。会扫描全部的FD，所以时间复杂度较差。 Redis采用的I/O多路复用函数：epoll/lqueue/evport/select 因地制宜 优先选择时间复杂度为O(1)的I/O多路复用函数作为底层实现 以时间复杂度为O(n)的select作为保底 基于react设计模式监听I/O事件 说说你用过的Redis的数据类型供用户使用的数据类型 String：最基本的数据类型，二进制安全 Hash：String元素组成的字典，适合用于存储对象 List：列表，按照String元素插入顺序排序，越新插入的值越先出 Set：String元素组成的无序集合，通过哈希表实现，不允许重复（添加成功为1，不成功为0。注：无序的，不要被图片误导） Sorted Set：通过分数来为集合中的成员进行从小到大的排序。 用于计数的HyperLogLog，用于支持存储地理位置信息的Geo 底层数据类型基础 简单动态字符串 链表 字典 跳跃表 整数集合 压缩列表 对象 从海量Key里查询出某一固定前缀的Key留意细节：摸清数据规模，即问清楚边界 KEYS pattern：查找所有符合给定模式pattern的key SCAN cursor [MATCH pattern] [COUNT count] 基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程 以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历 不保证每次执行都返回某个给定数量的元素，支持模糊查询 一次返回的数量不可控，只能是大概率符合count参数 使用keys对线上的业务的影响 KEYS指令一次性返回所有匹配的Key 键的数量过大会使服务卡顿 如何通过Redis实现分布式锁分布式锁需要解决的问题 互斥性，只有一个客户端能获取到锁 安全性，锁只有被持有锁的客户端删除，不能被其他客户端删除 死锁，客户端宕机而没有释放锁，其他客户端获取不到 容错，一些节点宕机时，客户端仍然能获取到锁，或释放锁 SETNX key value：如果key不存在，则创建并赋值。原子性 时间复杂度：O(1) 返回值：设置成功，返回1；设置失败。返回0 在获取锁之前，先使用SETNX，如果成功，则说明没有占用。 1234567RedisSerice redisService = SpringUtils.getBean(RedisService.class);long status = redisService.setnx(key,&quot;1&quot;);if(status = 1)&#123; redisService.expire(key, expire); **** //执行独占逻辑 doOcuppiedWork();&#125; 这段代码的缺点：在**** 处宕机的话，会锁住不放，原子性得不到满足。 如何解决SETNX长期有效的问题 EXPIRE key seconds 摄制key的生存时间，当key过期时(生存时间为0)，会被自动删除 为解决以上问题使用： SET key value [EX seconds] [PX milliseconds] [NX|XX] EX second：设置键的过期时间为second秒 PX millisecond：设置键的过期时间为millisecond毫秒 NX：只在键不存在时，才对键进行设置操作 XX：只在键已经存在时，才对键进行设置操作 SET操作成功完成时，返回OK，否则返回nil（空） 12345RedisService redisService = SpringUtils,getBean(RedisService.class);String result = redisService.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);if(&quot;OK&quot;.equals(result))&#123; doOcuppiedWork();&#125; 大量的key同时过期的注意事项集中过期，由于清除大量的key很耗时，会出现短暂的卡顿现象 解决方案：在设置key的过期时间的时候，给每个key加上随机值]]></content>
      <categories>
        <category>Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Offer-数据库16]]></title>
    <url>%2F2019%2F10%2F09%2FOffer-%E6%95%B0%E6%8D%AE%E5%BA%9316%2F</url>
    <content type="text"><![CDATA[剑指Offer-16数据库锁模块MyISAM于InnoDB关于锁方面的区别是什么 MyISAM默认用的是表级锁，不支持行级锁 在select语句时，会给表上一个读锁(共享锁)，可同时进行其他读的操作，但不可进行写操作。哪怕读1-10条，修改10条以外的数据也不行，不支持行级锁。 在insert、update、delete时，会给表加一个写锁(排它锁)，不可同时进行其他读或者写的操作。 可对select语句加上排它锁，末尾加for update 可对select语句加上共享锁，末尾加lock in share mode InnoDB默认用的是行级锁，也支持表级锁。 二段锁，加锁和解锁分为两个步骤执行。先对一批操作统一加锁，当commit时统一解锁，但commit是自动提交的，所以看起来于MyISAM没有太大差别。 MyISAM适合的场景 频繁执行全表count语句（MyISAM记录了全表的行数，不用重复对表进行扫描） 对数据进行增删改的频率不高，查询非常频繁。（MyIASM增删改进行锁表操作，插入会造成大量碎片，影响性能） 没有事务 InnoDB适合的场景 数据增删改查都相当频繁（锁行，避免堵塞） 可靠性要求比较高，要求支持事务 数据库锁的分类 按锁的粒度划分，可分为表级锁、行级锁、页级锁(锁定位于同一逻辑块的相邻几行数据) 按锁级别划分，可分为共享锁、排它锁 按加锁方式划分，可分为自动锁、显示锁 按操作划分，可分为DML锁（对数据操作）、DDL锁（对表结构操作） 按使用方式划分，可分为乐观锁、悲观锁 数据库事务的四大特性ACID 原子性（Atomic）：事务的操作要么全部执行，要么失败回滚 一致性（Consistency）：数据库中的数据应满足完整性约束。eg：转账 隔离性（Isolation）：一个事务的执行，不应该影响其他事务的执行 持久性（Durablilty）：一个事务的提交，他对数据库的修改应该永久的保存在数据库中。意味着系统发生故障时，确保事物的更新不会丢失 事务隔离级别以及各级别下的并发访问问题事务并发访问引起的问题以及如何避免 更新丢失(即同时操作的一个更新覆盖了另一个更新)–mysql所有事物隔离级别在数据库层面上均可避免 脏读(事务修改数据，但未提交，其他事务就已经查到已修改的数据。如果此时该事务没有提交而由于一些原因回滚，则出现大问题)–READ-COMMITTED事务隔离级别以上可避免。 不可重复读(A多次读取统一数据，此时B对数据进行更改，导致A读取不一致)–REPEATABLE-READ事务隔离级别以上可避免 幻读(A搜索和查询若干行，B进行添加或删除，可能会出现行数变化)–SERIALIZABLE事务隔离级别可避免 隔离级别越高安全性越高、串行化越严重，降低了并发度，所以需要根据实际情况，决定隔离级别。 InnoDB可重复读隔离级别下如何避免幻读 表象：快照读（非阻塞读）–伪MVCC（MVCC多版本并发控制读不加锁，读写不冲突），伪是因为并没有实现多版本共存 内在：next-key锁（行锁+gap锁） 表象：当前读和快照读 当前读：select…lock in share mode, select…for update 当前读：update，delete，insert 共享锁和排它锁都是当前读，即读取的数据都是最新版本，且其他并发线程不能修改当前数据。 eg：update修改数据时，向InnoDB发起当前读，获取最新版本，然后锁住，最后修改数据。 快照读：不加锁的非阻塞读，select。（不加锁的情况是在事务级别部位SERIALIZABLE的前提下才成立的） eg：在RR级别下，先使用快照读查询，其他线程修改数据，在使用快照读查询，可能为历史数据。如果先修改数据，在使用快照读，可能为最新数据。 RC、RR级别下的InnoDB的非阻塞读如何实现 数据行里的DB_TRX_ID（标识最后一次对本行做修改的ID）,DB_ROLL_PTR（回滚指针）,DB_ROW_ID（包含新行插入而单调自增的行ID）字段。 undo日志，对记录进行变更时产生undo记录，当我们需要历史记录时需要通过记录链找到我们需要的记录，一般事务回滚时需要用到。 read view，决定快照读可以看见的数据版本。当我们实行快照读，会创建一个read view可见性判断，他会根据数据修改的活跃性，不断比较Undo log中的DB_TRX_ID的值，直到得到最小的值，提交这份最稳定的数据。 undo日志： 内在：next-key锁（行锁+gap锁） 行锁：单个行上的锁 Gap锁：锁定一个范围，不包括记录本身。防止事物的两次当前读出现幻读的情况。 Gap锁在低级别事务中是没有的，所以READ-COMMITTED和RC无法避免幻读。RR和SERIALIZABLE可以避免。 对主键索引或者唯一索引会用Gap锁么 如果where条件全部命中，则不会用Gap锁，只会加行锁 如果where条件部分命中或全不命中，则用Gap锁。 Gap锁会用在非唯一索引或者不走索引的当前读中 非唯一索引会Gap一个范围，不走索引会Gap所有]]></content>
      <categories>
        <category>Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Offer-数据库15]]></title>
    <url>%2F2019%2F10%2F09%2FOffer-%E6%95%B0%E6%8D%AE%E5%BA%9315%2F</url>
    <content type="text"><![CDATA[剑指Offer-15数据库密集索引和稀疏索引的区别 密集索引文件中的每个搜索码值都对应一个索引值 稀疏索引文件只为索引码的某些值建立索引项 MySQL两大主流索引: MyISAM 主键索引、唯一键索引、普通键索引均属于稀疏索引 InnoDB 若一个主键被定义，该主键则作为密集索引 若没有主键被定义，该表的第一个唯一非空索引则作为密集索引 若不满足以上条件，innoDB内部会生成一个隐藏主键（密集索引，是一个6字节的列，列的值随着数据的插入而自增） 非主键索引存储相关键位和其对应的主键值，包含两次查找 衍生出的问题，以MySql为例：如何定义并优化慢查询Sql（具体场景具体分析，提出大致思路） 根据慢日志定位慢查询sql，慢日志(slow_query_log)用来记录执行较慢的sql set global slow_query_log = on; set global long_query_time =1; 使用explain等工具分析sql,分析sql语句执行低下的原因，从而改进查询。 直接在sql语句前添加explain id: 复合查询，id越大越先执行 type: mysql找到需要数据的方式 index、all表示为全表扫描，需要优化 extra: 修改sql或尽量让sql走索引 alter table person_info_large add index idx_name(name); mysql的查询优化器会尽量走索引，排除行的速度越快，查找就越快 有些情况采用密集索引时，可能叶子节点中存放其他数据而造成效率不如稀疏索引 联合索引的最左匹配原则的成因 简单说下什么是最左匹配原则: 顾名思义：最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(&gt;、&lt;、between、like)就会停止匹配。 例如：b = 2 如果建立(a,b)顺序的索引，是匹配不到(a,b)索引的；但是如果查询条件是a = 1 and b = 2或者a=1(又或者是b = 2 and b = 1)就可以，因为优化器会自动调整a,b的顺序。再比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，因为c字段是一个范围查询，它之后的字段会停止匹配。 最左匹配原则的原理: 最左匹配原则都是针对联合索引来说的，所以我们有必要了解一下联合索引的原理。了解了联合索引，那么为什么会有最左匹配原则这种说法也就理解了。 我们都知道索引的底层是一颗B+树，那么联合索引当然还是一颗B+树，只不过联合索引的健值数量不是一个，而是多个。构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。例子：假如创建一个（a,b)的联合索引，那么它的索引树是这样的 可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。所以b = 2这种查询条件没有办法利用索引，因为联合索引首先是按a排序的，b是无序的。 同时我们还可以发现在a值相等的情况下，b值又是按顺序排列的，但是这种顺序是相对的。所以最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引。例如a = 1 and b = 2 a,b字段都可以使用索引，因为在a值确定的情况下b是相对有序的，而a&gt;1and b=2，a字段可以匹配上索引，但b值不可以，因为a的值是一个范围，在这个范围中b是无序的。 成因： mysql创建复合索引的规则是首先会对复合索引的最左边，也就是索引中的第一个字段进行排序，在第一个字段排序的基础上，在对索引上第二个字段进行排序，其实就像是实现类似order by 字段1，字段2这样的排序规则，那么第一个字段是绝对有序的，而第二个字段就是无序的了，因此一般情况下直接只用第二个字段判断是用不到索引的，这就是为什么mysql要强调联合索引最左匹配原则的原因。 索引是建立的越多越好么 数据量小的表不需要建立索引，建立会增加额外的索引开销 数据变更需要维护索引，因此更多的索引意味着更多的维护成本 更多的索引意味着也需要更多的空间]]></content>
      <categories>
        <category>Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Offer-数据库14]]></title>
    <url>%2F2019%2F10%2F09%2FOffer-%E6%95%B0%E6%8D%AE%E5%BA%9314%2F</url>
    <content type="text"><![CDATA[剑指Offer-14数据库数据库架构如何设计一个关系型数据库RDBMS（数据库管理系统） 存储（文件系统）： 机械硬盘 固态硬盘 程序实例： 存储管理：将IO多行数据划成块或者页，一次读取多个块或页 缓存机制：优化存储效率，用A时，可能会读取同一块的BC，用BC时直接用 SQL解析：解析SQL语句，也放入缓存 日志管理：记录对数据库的操作 权限划分：多用户管理 容灾机制：如果数据库崩溃，应通过容灾机制恢复 索引管理：提高数据查询效率 锁管理：支持数据库并发操作 索引模块为什么要使用索引 如果将块都放入内存，逐行读取，如果数据量少的情况下，很快，但数据量多的时候，是十分慢的，所以需要加入索引，通过部分信息，找到数据位置 避免全表扫描寻找数据，快速查询数据 什么样的信息能成为索引 主键、唯一键以及普通键等，让数据有一定区分性的字段 索引的数据结构 建立二叉查找树进行二分查找 建立B-Tree结构进行查找 建立B+-Tree结构进行查找 建立Hash结构进行查找 二叉查找树上阵[O(log^n)] -&gt; [O(n)] 根据根节点，左边比父节点小，右边比父节点大。 但如果存入的数据的节点都越来越大，则二叉树越来越深，则时间复杂度变为O(n). B-Tree 定义： 根节点至少包括两个孩子 树中每个节点最多含有m个孩子（m&gt;=2）,m取决于容量和配置（根节点的孩子数） 除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子 （celi取上限，1.2=2；1.5=2）(关键子节点为2，孩子数为3，始终-1) 所有叶子节点位于同一层 假设每个非终端结点中包含有n个关键字信息，其中 a）Ki(i=1….n)为关键字，且关键字按顺序升序排序K(i-1)&lt;Ki b）关键字的个数n必须满足：[ceil(m/2)-1]&lt;=n&lt;=m-1 c）非叶子结点的指针：p[1],p[2],…,p[m];其中p[1]指向关键字小于K[1]的子树，p[M]指向关键字大于K[M-1]的子树，其它p[i]指向关键字属于(K[i-1]),k[i])的子树 B+-Tree[O(log^n)] B+树是B树的变体，其定义基本与B树相同，除了： 非叶子节点的子树指针与关键字个数相同(B+树可以存储更多的关键字) 非叶子节点的子树指针P[i]，指向关键字值(K[i],K[i+1])的子树 非叶子节点仅用来索引，数据都保存在叶子节点中（搜索10，10的数据可能保存在下面叶子的结点中） 所有的叶子节点均有一个链指针指向下一个叶子节点（方便统计） 结论 B+Tree更适合用来做存储索引 B+树的磁盘读写代价更低：非叶子节点只有索引，块中存放的关键字就越多，一次性放入内存的信息就越多 B+树的查询效率更加稳定：查找数据必须走一条从根节点到叶子节点的路 B+树更有利于对数据库的扫描：B树没有解决遍历数据效率底下的问题，B+数只需要遍历叶子节点就可以扫描全部数据 Hash索引也可以一下 通过Hash函数运算，一次定位到数据的头，效率理论上高于B+索引 但Hash索引也存在许多弊端 仅仅能满足“=”，“IN”，不能使用范围查询 无法被用来避免数据的排序操作，hash索引是经过运算的，跟存放数据的大小没有关系。 不能利用部分索引键查询，hash通过组合索引计算hash值，不能进行单个索引的查询 不能避免表扫描 遇到大量Hash值相等的情况后，性能不一定B-Tree索引高 BitMap索引（位图索引） 索引指定位图段，位图段中用一个bit位标志是与否，比如blue，用一个1标志这个位置是blue，所以统计很快。 缺陷：锁的力度大，可能因为其他数据的添加而让位置发生改变，所以需要锁住这段位图段。]]></content>
      <categories>
        <category>Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Offer-SpringAOP13]]></title>
    <url>%2F2019%2F09%2F18%2FOffer-SpringAOP13%2F</url>
    <content type="text"><![CDATA[剑指Offer-13框架知识考点 SpringAOP关注点分离：不同的问题交给不同的部分去解决 为了将事务、日志等通用化代码与业务代码分离开 面向切面编程AOP正式这种技术的体现 通用化功能代码的实现，对应的就是所谓的切面（Aspect） 业务功能代码和切面代码分开后，架构将变得高内聚低耦合 确保功能的完整性：切面最终需要被合并到业务中（Weave） AOP的三种织入方式 编译时织入：需要特殊的JAVA编译器，如AspectJ 类加载时织入：需要特殊的Java编译器，如AspectJ和AspectWerkz 运行时织入：Spring采用的方式，通过动态代理，实现简单 AOP的主要名词概念 Aspect（切面）：通用功能的代码实现 Target：呗织入Aspect的对象 JoinPoint：可以作为切入点的机会，所有方法都可以作为切入点 Pointcut：Aspect实际被应用在的JoinPoint，支持正则表达式 Advice：类里的方法以及这个方法如何织入到目标方法的方式 Weaving：Aop的实现过程 Advice的种类 前置通知（Before） 后置通知（AfterReturning） 异常通知（AfterThrowing） 最终通知（After） 环绕通知（Around） AOP的实现：JDKProxy（JDK动态代理）和Cglib 具体生成由AopProxyFactory根据AdvisedSupport对象的配置来决定 默认策略如果目标类是接口，则用JDKProxy来实现，否则后者 JDKProxy的核心：InvocationHandler接口和Proxy类 Cglib：以继承的方式动态生成目标类的代理，以字节码实现代理 JDKProxy：通过Java的内部反射机制实现 Cglib：借助ASM实现 反射机制在生成类的过程中比较高效 ASM在生成类之后的执行过程中比较高效 代理模式：接口+真实实现类+代理类Spring里的代理模式的实现 真实实现类的逻辑包含了getBean方法里 getBean方法返回的实际上是Proxy的实例，getBean用于查找或实例化容器中的Bean Proxy（代理类）实例时Spring采用的JDK Proxy或CGLIB动态生成的 Spring事务的相关考点 ACID 隔离级别 事务传播]]></content>
      <categories>
        <category>Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Offer-SpringIOC12]]></title>
    <url>%2F2019%2F09%2F18%2FOffer-SpringIOC12%2F</url>
    <content type="text"><![CDATA[剑指Offer-12框架知识考点 SpringIOC家族体系你了解Spring IOC么IOC（Inversion of Control）：控制反转，是一种思想 Spring Core最核心部分 需要先来了解依赖注入（DI）： DI举例：设计行李箱 轮子 &lt;—-依赖—- 底盘 &lt;—-依赖—- 箱体 &lt;—-依赖—- 行李箱 如果要改变轮子的大小，都得改动 含义：把底层类作为参数传递给上层类，实现上层对下层的“控制” IOC、DI、DL的关系 DL:Dependency Lookup 更为主动，调用框架中的方法获取对象，需要提供配置文件路径。（DL已经被抛弃，需要用户自己调用API进行查找，有侵入性）。 DI：Dependency Injection，Spring、google使用的方式。（Set注入、接口注入、注解注入、构造器注入） 依赖注入的方式Setter Interface Constructor(构造器) Annotation（注解） 依赖倒置原则、IOC、DI、IOC容器的关系依赖倒置原则（一种思想，高级模块不应该依赖于低级模块）—-&gt; 控制反转（IOC） —–&gt;（方法：依赖注入[DI]、第三方容器：控制反转容器[IOC容器]） IOC容器的优势 避免在各处使用new来创建类，并且可以做到统一维护 创建实例的时候不需要了解其中的细节 SpringIOC支持的功能依赖注入、依赖检查、自动装配、支持集合、指定初始化方法和销毁方法、回调方法 SpringIOC容器的核心街口BeanFactory：Spring框架最核心的接口 提供IOC的配置机制 包含Bean的各种定义，便于实例化Bean 建立Bean之间的依赖关系 Bean生命周期的控制 ApplicationContext的功能（继承以下接口） BeanFactory：能够管理、装配Bean ResourcePatternResolver：能够加载资源文件 MessageSource：能够实现国际化等功能 ApplicationEventPublisher：能够注册监听器，实现监听功能 BeanFactory与ApplicationContext的比较 BeanFactory是Spring框架的基础设施，面向Spring ApplicationContext面向使用Spring框架的开发者 BeanDefinition： BeanDefinitionRegistry: 提供向IOC容器注册BeanDefinition对象的方法 SpringIOC支持的功能 依赖注入 依赖检查 自动装配 支持集合 指定初始化方法和销毁方法 支持回调方法 getBean方法的代码逻辑 转换beanName 从缓存中加载实例 实例化Bean 检测parentBeanFactory 初始化依赖的Bean 创建Bean Spring Bean的作用域 singleton：Spring的默认作用域，容器里拥有唯一的Bean实例 prototype：针对每个getBean请求，容器都会创建一个Bean实例 request：会为每个Http请求创建Bean实例 session：会为每个session创建一个Bean实例 globalSession：会为每个全局Http Session创建一个Bean实例，该作用域仅对Portlet有效 Spring Bean的生命周期 销毁过程 若实现了DisposableBean接口，则会调用destroy方法 若配置了destry-method属性，则会调用其配置的销毁方法]]></content>
      <categories>
        <category>Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot搭建RESTful]]></title>
    <url>%2F2019%2F09%2F16%2FSpringboot%E6%90%AD%E5%BB%BARESTful%2F</url>
    <content type="text"><![CDATA[Springboot搭建RESTful WebRestful简介Restful一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 RESTful架构一个核心概念是“资源”(Resource) 。从RESTful的角度看，网络里的任何东西都是资源，它可以是一段文本、-张图片、一首歌曲、一种服务等，每个资源都对应一个特定的URI (统一资源定位符)，并用它进行标示，访问这个URI就可以获得这个资源。 GET，获取结果、第二次也是获取结果对资源都不会造成影响 POST，新增数据，第二次也会再次新增 PUT， 更新数据，第二次不会再次更新 PATCH，更新数据，第二次不会再次更新 DELETE，删除数据，第二次不在再删除 优点 轻量，直接基于http，不再需要任何别的诸如消息协议。get/post/put/delete为CRUD操作 面向资源，一目了然，具有自解释性。 数据描述简单，一般以xml，json做数据交换。 无状态，在调用一个接口（访问、操作资源）的时候，可以不用考虑上下文，不用考虑当前状态，极大的降低了复杂度。 简单、低耦合 简单实例1.构建数据库123456CREATE TABLE `t_user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;id&apos;, `name` varchar(10) DEFAULT NULL COMMENT &apos;姓名&apos;, `age` int(2) DEFAULT NULL COMMENT &apos;年龄&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8; 2.相关依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;mybatis-spring-boot&gt;1.2.0&lt;/mybatis-spring-boot&gt; &lt;mysql-connector&gt;5.1.39&lt;/mysql-connector&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- Spring Boot Mybatis 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-spring-boot&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL 连接驱动依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql-connector&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3.结构说明123456com.example.controller - Controller 层com.example.dao - 数据操作层 DAOcom.example.entity - 实体类com.eaxmple.service - 业务逻辑层TestApplication - 应用启动类application.properties - 应用配置文件，应用启动会自动读取配置 4.配置文件一般我们需要一些自定义的配置，例如配置jdbc的连接配置，在这里我们可以用 application.properties 进行配置。数据源实际的配置以各位的为准。 1234567891011## 数据源配置spring.datasource.url=jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf8spring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.jdbc.Driver## Mybatis 配置# 配置为 com.example.bean 指向实体类包路径。mybatis.typeAliasesPackage=com.example.entity# 配置为 classpath 路径下 mapper 包下，* 代表会扫描所有 xml 文件。mybatis.mapperLocations=classpath\:mapper/*.xml 5.代码编写在创建好相关工程目录之后，我们开始来编写相应的代码。 5.1 实体类编写由于我们这里只是用于测试，只在数据库中创建了一张t_user表，所以这里我们就只创建一个User实体类，里面的字段对应t_user表的字段。 示例代码如下: 1234567891011public class User &#123; /** 编号 */ private int id; /** 姓名 */ private String name; /** 年龄 */ private int age; public User()&#123; &#125;// getter和 setter 略 &#125; 5.2 Dao层编写在以前的Dao层这块，hibernate和mybatis 都可以使用注解或者使用mapper配置文件。在这里我们使用spring的JPA来完成基本的增删改查。说明:一般有两种方式实现与数据库实现CRUD：第一种是xml的mapper配置。第二种是使用注解，@Insert、@Select、@Update、@Delete 这些来完成。本篇使用的是第二种。 1234567891011121314151617181920212223242526272829303132333435363738package com.example.dao;import com.example.entity.User;import org.apache.ibatis.annotations.*;import java.util.List;@Mapperpublic interface UserDao &#123; /** * 用户数据新增 */ @Insert(&quot;insert into t_user(id,name,age) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;)&quot;) void addUser(User user); /** * 用户数据修改 */ @Update(&quot;update t_user set name=#&#123;name&#125;,age=#&#123;age&#125; where id=#&#123;id&#125;&quot;) void updateUser(User user); /** * 用户数据删除 */ @Delete(&quot;delete from t_user where id=#&#123;id&#125;&quot;) void deleteUser(int id); /** * 根据用户名称查询用户信息 */ @Select(&quot;SELECT id,name,age FROM t_user where id=#&#123;userId&#125;&quot;) User findById(@Param(&quot;userId&quot;) Integer userId); /** * 查询所有 */ @Select(&quot;SELECT id,name,age FROM t_user&quot;) List&lt;User&gt; findAll();&#125; 说明: mapper : 在接口上添加了这个注解表示这个接口是基于注解实现的CRUD。 Results: 返回的map结果集，property 表示User类的字段，column 表示对应数据库的字段。 Param: sql条件的字段。 Insert、Select、Update、Delete:对应数据库的增、查、改、删。 5.3 Service 业务逻辑层接口 123456789101112131415161718192021222324252627282930313233343536373839package com.example.service;import com.example.entity.User;import java.util.List;public interface UserService &#123; /** * 新增用户 * @param user * @return */ boolean addUser(User user); /** * 修改用户 * @param user * @return */ boolean updateUser(User user); /** * 删除用户 * @param id * @return */ boolean deleteUser(int id); /** * 根据用户ID查询用户信息 * @param userId */ User findUserById(Integer userId); /** * 查询所有 * @return */ List&lt;User&gt; findAll();&#125; 实现类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.example.service.impl;import com.example.dao.UserDao;import com.example.entity.User;import com.example.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; @Override public boolean addUser(User user) &#123; boolean flag=false; try&#123; userDao.addUser(user); flag=true; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return flag; &#125; @Override public boolean updateUser(User user) &#123; boolean flag=false; try&#123; userDao.updateUser(user); flag=true; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return flag; &#125; @Override public boolean deleteUser(int id) &#123; boolean flag=false; try&#123; userDao.deleteUser(id); flag=true; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return flag; &#125; @Override public User findUserById(Integer userId) &#123; return userDao.findById(userId); &#125; @Override public List&lt;User&gt; findAll() &#123; return userDao.findAll(); &#125;&#125; 5.4 Controller 控制层说明: RestController：（@Controller + @ResponseBody）默认类中的方法都会以json的格式返回。 RequestMapping: 接口路径配置。 method : 请求格式。 RequestParam: 请求参数。 具体实现如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.example.controller;import com.example.entity.User;import com.example.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;@RestController@RequestMapping(value = "/api")public class UserRestController &#123; @Autowired private UserService userService; //@RequestMapping(value = "/user", method = RequestMethod.POST) @PostMapping(value = "/user") public boolean addUser( User user) &#123; System.out.println("开始新增..."); return userService.addUser(user); &#125; //@RequestMapping(value = "/user", method = RequestMethod.PUT) @PutMapping(value = "/user") public boolean updateUser( User user) &#123; System.out.println("开始更新..."); return userService.updateUser(user); &#125; //@RequestMapping(value = "/user", method = RequestMethod.DELETE) @DeleteMapping(value = "/user/&#123;userId&#125;") public boolean delete(@PathVariable Integer userId) &#123; System.out.println("开始删除..."); return userService.deleteUser(userId); &#125; //@RequestMapping(value = "/user", method = RequestMethod.GET) @GetMapping(value = "/user/&#123;userId&#125;") public User findByUserName(@PathVariable Integer userId) &#123; System.out.println("开始查询..."); return userService.findUserById(userId); &#125; //@RequestMapping(value = "/userAll", method = RequestMethod.GET) @GetMapping(value = "/user") public List&lt;User&gt; findByUserAge() &#123; System.out.println("开始查询所有数据..."); return userService.findAll(); &#125;&#125; 5.5 Application 主程序SpringApplication 则是用于从main方法启动Spring应用的类。默认，它会执行以下步骤：1.创建一个合适的ApplicationContext实例 （取决于classpath）。2.注册一个CommandLinePropertySource，以便将命令行参数作为Spring properties。3.刷新application context，加载所有单例beans。4.激活所有CommandLineRunner beans。直接使用main启动该类，SpringBoot便自动化配置。 该类的一些注解说明。:SpringBootApplication：开启组件扫描和自动配置。MapperScan: mapper 接口类扫描包配置 代码如下： 12345678910111213package com.example;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@MapperScan("com.example.dao")public class TestApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TestApplication.class, args); &#125;&#125; 6.代码测试代码编写完之后，我们进行代码的测试。启动Application 之后，使用postman工具进行接口的测试。 postman是一款功能强大的网页调试和模拟发送HTTP请求的Chrome插件，支持几乎所有类型的HTTP请求，操作简单且方便。 安装包安装： 官网下载地址:https://www.getpostman.com选择好对应的版本下载,下载完后直接安装 测试结果如下: 查询： 添加： ID查询： 删除：]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Offer-类11]]></title>
    <url>%2F2019%2F09%2F07%2FOffer-%E7%B1%BB11%2F</url>
    <content type="text"><![CDATA[剑指Offer-11常见类库与技巧java5之前无论是Hashtable还是synchronized包装下的hashmap在多线程并发下，都要竞争同一把锁。所以产生了ConcurrentHashMap. 如何优化Hashtable？ 通过锁细粒度化，将整锁拆解成多个锁进行优化 早期的ConcurrentHashMap：通过分段锁segment实现，即为默认的16个数组位置，每个都分配一把锁，线程可同时访问不同位置。 Java8之后，当前的ConcurrentHashMap：CAS+synchronized 使锁更加细化，也采用了数组+链表+红黑树 synchronized只锁住当前列表或者红黑树的首节点，只要hash不冲突，就不会产生并发 ConcurrentHashMap：put方法的逻辑 判断Node[]数组是否初始化，没有则进行初始化操作 通过hash定位数组的索引坐标，是否有Node节点，如果没有则使用CAS进行添加(链表的头节点)，添加失败则进入下次循环。 检查到内部正在扩容，就帮助它一块扩容。 如果f!=null,则使用sunchronized锁住f元素 (链表/红黑二叉树的头元素) 如果是Node（链表结构）则执行链表的添加操作 如果是TreeNode（树形结构）则执行树添加操作 判断链表长度已经达到临界值8，当然这个8是默认值，也可以去做调整，当节点数超过这个值就需要把链表转换为树结构 ConcurrentHashMap总结：比起Segment，锁拆得更细 首先使用无锁操作CAS插入头节点，失败则循环重试 若头节点存在，则用synchronized尝试获取头节点的同步锁，再进行操作 ConcurrentHashMap：别的需要注意的点 size（）方法和mapping Count（）方法的异同，两者计算是否准确？ 多线程环境下如何扩容？ HashMap、Hashtable、ConcurrentHashMap区别 HashMap：线程不安全，数组+链表+红黑树 Hashtable：线程安全，锁住整个对象，效率低，数组+链表 ConcurrentHashMap：线程安全，CAS+同步锁，锁住对象下的元素，数组+链表+红黑树 hashMap的key、value均可为null，而其他两个不支持 J.U.C 知识点梳理java.util.concurrent：提供了并发编程的解决方案CAS是java.util.concurrent.atomic包的基础 AQS是java.util.concurrent.locks包以及一些常用类比如Semophore，ReentrantLock等类的基础 J.U.C 包的分类 线程执行器executor：任务执行和调度的框架 锁locks：Condition显示锁 原子变量类atomic：有原子性的类，方便在多线程环境下进行无锁操作 并发工具类tools：后面详细介绍 并发集合collections：后面详细介绍 并发工具类tools：四个同步器闭锁CountDownLatch：让主线程等待一组事件发生后继续执行 事件指的是CountDownLatch里的countDown()方法 eg：三个线程分别执行countDown()方法，有一个计数器为3，一个线程执行一个方法后-1，为0时，主线程继续执行 栅栏CyclicBarrier：阻塞当前线程，等待其他线程 也有一个计数器，执行await()方法，执行后-1。 等待其他线程，且会阻塞自己当前的线程，所有线程必须同时到达栅栏位置后，才能继续执行； 所有线程到达栅栏处，可以出发执行另一个预先设置的线程 信号量Semaphore：控制某个资源可被同时访问的线程个数 通过require获取资源，没有则等待，利用资源后，通过释放一个release，许可一个线程进入 交换器Exchanger：两个线程到达同步点后，相互交换数据 提供了一个交换点，两个线程到达交换点后，相互交换数据，一个线程先到达同步点，就会被阻塞，直到另一个线程到达（只能是两个线程） 并发集合collections：BlockingQueue:提供可阻塞的入队和出队操作 主要用于生产者-消费者模式，在多线程场景时，生产者线程在队列尾部添加元素，而消费者线程则在队列头部消费元素，通过这种方式能够达到将任务的生产和消费进行隔离的目的。 七个队列实现，均线程安全，前三个比较重要： ArrayBlockingQueue:一个由数组结构组成的有界（容量有限）阻塞队列；（尾入头出） LinkedBlockingQueue：一个由链表结构组成的有界/无界阻塞队列；（尾入头出） PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列；（按优先级） DealyQueue：一个使用优先级队列实现的无界阻塞队列；（可设置延迟，时间到了才获取元素） SynchronousQueue：一个不存储元素的阻塞队列；（仅允许有一个元素） LinkedTransferQueue：一个由链表结构组成的无界阻塞队列；（2和5的结合体） LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列；（消费者双端任务完成之后，可以窃取其他消费者队列的尾部任务） Java的IO机制BIO、NIO、AIO的区别Block-IO：InputStream和OutputStream，Reader和Writer（弄清楚四者区别） 特点：在IO执行的两个阶段都被阻塞住了 优点：代码简单、直观 缺点：扩展性和效率都不好 NonBlock-IO：构建多路复用的、同步非阻塞的IO操作 特点：IO执行第一阶段不阻塞，而是程序不断地询问内核是否准备好，第二阶段阻塞 NIO的核心 Channels(可以和buffer相互传递数据) FileChannel transferTo：把FileChannel中的数据拷贝到另外一个Channel transferFrom：把另外一个Channel中的数据拷贝到FileChannel 避免了两次用户态和内核态间的上下文切换，即“零拷贝”，效率高 DatagramChannel SocketChannel ServerSocketChannel 自己私下了解 Buffers（能通过IObuffer的基本数据类型） ByteBuffer CharBuffer DoubleBuffer FloatBuffer IntBuffer LongBuffer ShortBuffer MappedByteBuffer：表示内存映射文件 Selectors（允许单线程处理多个Channel） 如果应用打开多个链接，每个链接流量都很低，可用Selectors eg：聊天服务器 IO多路复用：调用系统级别的select、poll、epoll优点：单线程可以同时处理多个网络IO，系统监控IO状态，select监控IO请求，有一个socket数据准备好，便可返回。 select、poll、epoll的区别支持一个进程所能打开的最大连接数 select：单个进程所能打开的最大连接数由FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小是32x32，64位上是32x64），我们可以对其进行修改，然后重新编译内核，但是性能无法保证，需要做进一步尝试。基于数组，所以连接数有限/ poll:本质上与select没有区别，但是它没有最大连接数限制，原因是它是基于链表存储的 epoll：虽然连接数有上限，但是很大，1G内存的机器上可以打开10w左右的连接 FD剧增后带来的IO效率问题 select:因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成便利速度的“线性下降”的性能问题 poll：同上； epoll：由于epoll是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll不会有“线性下降”的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。 消息传递方式 select：内核需要将消息传递到用户空间，需要内核的拷贝动作 poll：同上 epoll：通过内核和用户空间共享一块内存来实现，性能较高 Asychronous IO：基于事件和回调机制 AIO如何进一步加工处理结果 基于回调：实现CompletionHandler接口，调用时触发回调函数 返回Future：通过isDone（）查看是否准备好，通过get（）等待返回数据 BIO\NIO\AIO源码看视频 BIO、NIO、AIO的对比属性\模型 阻塞BIO 非阻塞NIO 异步AIO blocking 阻塞并同步 非阻塞但同步 非阻塞并异步 线程数(server:client) 1:1 1:N 0:N 复杂度 简单 较复杂 复杂 吞吐量 低 高 高 BIO：连接数较小，固定的架构 NIO：连接数、连接短的操作，如聊天服务器 AIO：连接数多，连接长的操作]]></content>
      <categories>
        <category>Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Offer-类10]]></title>
    <url>%2F2019%2F09%2F07%2FOffer-%E7%B1%BB10%2F</url>
    <content type="text"><![CDATA[剑指Offer-10常见类库与技巧String、StringBulider、StringBuffer的区别Java异常以及常用工具类的体系Java异常处理机制主要回答了三个问题 what：异常类型回答了什么被抛出 where：异常堆栈跟踪回答了在哪抛出 why：异常信息回答了为什么被抛出 Java的异常体系 Object -&gt; Throwable -&gt; Error 、Exception -&gt;(Exception) RuntimeException、非RuntimeException 从概念角度解析Java的异常处理机制 Error：程序无法处理的系统异常错误，编译器不做检查 （一般是指与JVM相关的问题：系统崩溃、虚拟机错误、内存不足、方法栈溢出） Exception：程序可以处理的异常，捕获后可能恢复 总结：前者是程序无法处理的错误，后者程序可以处理 RuntimeException：不可预知的，程序应当自行避免（下标越界、空指针等） 非RuntimeException：可预知的，从编译器校验的异常（io、sql） 从责任角度看： Error属于JVM需要负担的责任； RuntimeException是程序应该负担的责任 CheckedException可检查异常时Java编译器应该负担的责任 常见的Error以及ExceptionRuntimeException NullPointerException -空指针引用异常 ClassCastException -类型强制转换异常 IllegalArgumentException -传递非法参数异常 IndexOutOfBoundsException -下标越界异常 NumberFormatException -数字格式异常 非RuntimeException ClassNotFoundException -找不到指定的class异常 IOException -IO操作异常 Error NoClassDefFoundError -找不到class定义的异常 类依赖的class或者jar不存在 类文件存在，但是存在不同的域中 大小写问题，javac编译的时候无视大小写，很有可能编译后class文件与想要的不一样 StarkOverFlowError -深递归导致栈被耗尽的异常 OutOfMemoryError -内存溢出异常 Java的异常处理机制 抛出异常：创建异常对象，交由运行时系统处理 捕获异常：寻找合适的异常处理器（ExceptionHandler）处理异常，否则终止运行（多个catch，按顺序依次查询是否有符合的方法，错误越精准越好） Java异常的处理原则 具体明确：抛出的异常应能通过异常类名的message准确说明异常的类型和产生异常的原因； 提早抛出：应尽可能早的发现并抛出异常，便于精准定位； 延迟捕获：异常的捕获和处理应尽可能延迟，让掌握更多信息的作用域来处理异常。 高效主流的异常处理框架在用户来看，应用系统发生在所有异常都是应用系统内部的异常 设计一个通用的继承自RuntimeException的异常来统一处理 其余异常都统一转译为上述异常AppException 在catch之后，抛出上述异常的子类，并提供足以定位的信息 由前端接收AppException做统一处理 Java异常处理消耗性能的地方 try-catch块影响JVM的优化 异常对象实例需要保存栈快照等信息，可以从异常中看到对象等信息，说明信息量很大，开销较大，缩进尽量精确到某一处的异常。 Java集合框架工作中消失而面试却长存的算法和数据结构优秀的算法和数据结构被封装到了Java的集合框架中 数据结构考点 数组和链表的区别 链表的操作，如反转、链表环路检测、双向链表、循环链表相关操作； 队列，栈的应用； 二叉树的遍历方式以及其递归和非递归的实现； 红黑树的旋转 算法考点 内部排序：递归排序、交换排序（冒泡、快排）、选择排序、插入排序 外部排序：应掌握如何利用有限的内存配合海量的外部存储来处理超大的数据集，至少要有相关思路（分化处理再合并） 考点扩展： 那些排序是不稳定的（快排、堆排序），稳定意味着什么 不同的数据集，各种排序最好和最差的情况 如何优化算法(以空间还时间等) List和Set 代码需重复看 MapHashMap、HashTable、ConccurentHashMapHashMap（Java8以前）：数组+链表，长度默认为16； 数组：查询速度快、增删较慢；链表反之； HashMap结合了两者优点； 操作方式非synchronized，效率高； 因为放入HashMap的值通过哈希散列运算总是得出相同的值，一直放入一个桶中，会使某个链表变得很长，从头部逐个遍历，性能会从O（1）变O（n） HashMap（Java8以后）：数组+链表+红黑树。性能从O（n）提高到O(logn); 红黑树课下要明白 HashMap：put方法的逻辑 如果HashMap未被初始化过，则初始化 对key求Hash值，然后再计算下标 如果没有碰撞（table中没有相对应的键值对），直接放入桶中 如果碰撞了，以链表的方式链接到后面 如果链表长度超过阈值，就把链表转成红黑树 如果链表长度低于6，就把红黑树转成链表 如果节点已经存在，就替换旧制 如果桶满了（容量16*加载因子0.75），就需要resize（扩容2倍后重排） hashMap：set方法的逻辑 使用键对象的HashCode，使用哈希算法找到键值位置，通过key.equals找到值 HashMap：如何有效减少碰撞扰动函数：促使元素位置分布均匀，减少碰撞几率，目的是让不同对象返回不同的HashCode 使用final对象，并采用合适的equals()和Hashcode()方法，可以缓存不同键的HashCode。使用String、Intger作为键比较好，是final的，重写了equals和hashcode的方法 HashMap：从获取hash到散列的过程 HashMap:扩容的问题 多线程环境下，调整大小会存在条件竞争（两个线程都发现Hashmap需调整），容易造成死锁 rehashing（散列）是一个比较耗时的过程 HashMap知识点： 成员变量：数据结构，树化阈值 构造函数：延迟创建 put和get的流程 哈希算法，扩容，性能]]></content>
      <categories>
        <category>Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Offer-Thread09]]></title>
    <url>%2F2019%2F09%2F04%2FOffer-Thread09%2F</url>
    <content type="text"><![CDATA[剑指Offer-09Java多线程与并发-原理Java线程池 如果并发的线程非常多，并且线程执行时间短，就会频繁的创建和销毁线程，效率就会大大降低 利用Executors创建不同的线程池满足不同场景的需求 newFixedThreadPool(int nThreads) 指定工作线程数量的线程池 newCachedThreadPool() 处理大量短时间工作任务的线程池 （1）试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程； （2）如果线程闲置的时间超过阈值，则会被终止并移出缓存； （3）系统长时间闲置的时候，不会消耗什么资源； newSingleThreadExecutor() 创建唯一的工作者线程来执行任务，如果线程异常结束，会有另一个线程来取代他 newSingleThreadScheduledExecutor()与newScheduledThreadPool(int corePoolSize) 定时或者周期性的工作调度，两者的区别在于单一工作线程还是多线程 newWorkStealingPool() 内部会创建ForkJoinPool，利用working-stealing算法，并行地处理任务，不保证处理顺序 Fork/Join框架 把大任务分割成若干个小任务并行执行，最终汇总每个小任务结果后得到大任务结果的框架。 Work-Stealing算法：某个线程从其他队列里窃取任务来执行。 但如果有的小任务已完成等待其他任务完成，闲置会浪费。会使用双端队列，便于线程来窃取其他队列中等待的任务。（被窃取队列从头部拿任务，窃取从尾部） 为什么要使用线程池 降低资源消耗，重复利用已创建线程 提高线程的可管理性 Executor框架 是一种将人物提交和任务执行分离开的机制。 J.U.C的三个Executor的结果 Executor：运行新任务的简单接口，将任务提交和任务执行细节解耦 123Thread t = new Thread；t.start(); //正常线程开始执行executor.execute(t);//Executor接口的线程开始方法 ExecutorService:具备管理执行器和任务生命周期的方法，提交任务机制更完善；【submit（Callable）方法解决了Runnable没有返回接口的短板，完善了提交任务的机制】 ScheduledExecutorService：支持Future的定期执行任务 ThreadPoolExecutorThreadPoolExecutor的构造函数 corePoolSize：核心线程数量（长期驻留的线程） maximumPoolSize：线程不够用时能够创建的最大线程数 workQueue：任务等待队列（当任务提交时，线程池中的线程数量&gt;=corePoolSize，会把其封装成work对象放入等待队列中） keepAliveTime：线程池允许的空闲时间，核心线程外的线程在期间内没有任务，则被销毁 threadFactory：创建新线程，Executor.defaultThreadFactory() Handler:线程池的饱和策略，阻塞队列满了，还没有空闲线程，如果继续提交任务，有四种策略： AbortPolicy：直接抛出异常，默认策略 CallerRunsPolicy：用调用者所在的线程来执行任务 DiscardOldestPolicy：丢弃队列中最靠前的任务，并执行当前任务 DiscardPolicy：直接丢弃任务 实现RejectedExecutionHander接口的自定义Handler 新任务提交execute执行后的判断 如果运行的线程少于corePoolSize,则创建新线程来处理任务，即使线程池中其他线程是空闲的。 如果线程池中的线程数量大于等于corePoolSize且小于maximumPoolSize，则只有当workQueue满时才创建新的线程去处理任务； 如果设置的corePoolSize和maximumPoolSize相同，则创建的线程池的大小是固定的，这时如果有新任务提交，若workQueue未满，则将请求放入workQueue中，等待有空闲的线程去从workQueue中取任务并处理； 如果运行的线程数量大于等于maximumPoolSize，这时如果workQueue已经满了，则通过handler所制定的策略来处理任务 线程池的状态 RUNING:能接受新提交的任务，并且也能处理阻塞队列中的任务 ShutDown：不再接受新提交的任务，但可以处理存量任务（阻塞队列中的任务）【running调用shutdown方法】 Stop：不能接受新提交的任务，也不处理存量任务【running调用stop】 Tidying:所有任务都已终止，有效线程数为0【shutdown或stop调用】 Terminated：terminated（）方法执行完后进入该状态，（什么也不做，只是一个标识） 工作线程的生命周期 开始 -&gt; execute -&gt; 增加worker -&gt; 创建worker线程 -&gt; runWorker -&gt; 获取任务 -&gt; task == null 【-&gt; true -&gt; 结束线程 -&gt; 结束】【-&gt; false -&gt; 执行任务 —&gt; 结束线程或获取任务】 线程池的大小选定 任务主计算：CPU密集型：线程数 = 按照核数或者核数 + 1 设定 任务处理较多任务：I/O密集型： 线程书 = CPU核数 * (1 + 平均等待时间/平均工作时间 ） 推荐书籍：《Java并发编程实战》]]></content>
      <categories>
        <category>Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Offer-Thread08]]></title>
    <url>%2F2019%2F09%2F04%2FOffer-Thread08%2F</url>
    <content type="text"><![CDATA[剑指Offer-08Java多线程与并发-原理jmm的内存可见性什么是Java内存模型中的happens-before Java内存模型JMM Java内存模型(即Java Memory Model,简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。 JMM中的主内存 存储Java实例对象 包括成员变量、类信息、常量、静态变量等 属于数据共享的区域，多线程并发操作时会引发线程安全问题 JMM中的工作内存 存储当前方法的所有本地变量信息，本地变量对其他线程不可见 字节码行号指示器，Native方法信息 属于线程私有数据区域，不存在线程安全问题 JMM与Java内存区域划分是不同的概念层次 JMM描述的是一组规则，围绕原子性，有序性，可见性展开 相似点：存在共享区域(堆、方法栈)和私有区域(程序计数器，JVM虚拟机栈、本地方法栈) 主内存与工作内存的数据存储类型以及操作方式归纳 方法里的基本数据类型本地变量将直接存储在工作内存的栈帧结构中。 引用类型的本地变量：引用存储在工作内存中，实例存储在主内存中。 成员变量、static变量、类信息存储在主内存中。 主内存共享的方式是线程各拷贝一份数据到工作内存，操作完成后刷新回主内存。 指令重排序需要满足的条件 在单线程环境下不能改变程序运行的结果 存在数据依赖关系的不允许重排序 无法通过happens-before原则推导出来的，才能进行指令的重排序 A操作的结果需要对B操作可见，则A与B存在happens-before关系 i = 1; //线程A执行 j = i；//线程B执行 happens-before的八大原则 程序次序原则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作； 锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作； volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作； 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C； 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作； 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生； 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束，Thread.isAlive()的返回值手段检测到线程已经终止执行； 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始； happens-before的概念 如果两个操作不满足上述任意一个happens-before规则，那么这两个操作就没有顺序的保障，JVM可以对这两个操作进行重排序； 如果操作A happens-before操作B，那么操作A在内存上所做的操作对操作B都是可见的 123456789private int value = 0;public void write(int input)&#123; //A value = input;&#125;public int read()&#123; //B return value;&#125;这一段代码不满足1.2.3.4规则，与5.6.7.8没有关系，所以不是线程安全的可以加入synchronized锁，或者对value加入volatile volatile：JVM提供的轻量级同步机制保证被volatile修饰的共享变量对所有线程总是可见的 禁止指令重排序优化 volatile的可见性12345678910public class VolatileVisibility&#123; public static volatile int value = 0; public static void increase()&#123; value++; &#125;&#125; //value++,多线程时，不是线程安全的，不具备原子性，它是对值的读取，在写回一个新值，如果在这个期间，有一个线程一起看到这个值，就会同时对value进行+1，值只加了1，不是2.public class VolatileVisibility&#123; public static volatile int value = 0; public synchronized static void increase()&#123; value++; &#125;&#125; 12345public class VolatileSafe&#123; volatile boolean shutdown； public void close（）&#123; shutdown=true；&#125;&#125; //由于shutdown=true；有原子性，所以volatile线程时安全的 volation变量为何立即可见？ 当写一个volatile变量时，JMM会把该线程对应的工作内存中的共享变量值刷新到主内存中； 当读取一个volatile变量时，JMM会把该线程对相应的工作内存置为无效，线程只能从主内存重新读取变量，起到刷新作用。 volatile如何禁止重排优化内存屏障（Memory Barrier） 1.保证特定操作的执行顺序 通过插入内存屏障指令禁止在内存屏障前后的指令执行重排序优化。 2.保证某些变量的内存可见性 强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本 实现线程安全的单例写法：单利的双重检测实现1234567891011121314151617public class Singleton&#123; private volatile static Singleton instance; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; //第一次检测 if(instance == null)&#123; //同步 synchronized (Singleton.class)&#123; if(instance == null)&#123; //多线程环境下可能会出现问题的地方 instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; volatile和synchronized的区别 volatile本质是在告诉JVM当前变量在寄存器(工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住直到该线程完成变量操作为止。 volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、类级别。 volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量修改的可见性和原子性 volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞； volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化 CAS（Compare and Swap） 一种高效实现线程安全性的方法 支持原子更新操作，适用于计数器，序列发生器（给变量自增的工具）等场景 属于乐观锁机制，号称lock-free CAS操作失败时由开发者决定是继续尝试，还是执行别的操作 CAS思想包含三个操作数 – 内存位置（V、即主内存的值）、预期原值（A）和新值（B） 将V与A相比较，如果匹配，则将该位置的值更新为B CAS多数情况下对开发者来说是透明的 J.U.C的atomic包提供了常用的原子性数据类型以及引用、数组等相关原子类型和更新操作工具，是很多线程安全程序的首选 Unsafe类虽提供CAS服务，但因能够操纵任意内存地址读写而有隐患 Java9以后，可以使用Variable Handle API来代替Unsafe 缺点若循环时间长，则开销很大 只能保证一个共享变量的原子操作 ABA问题（A-&gt;B-&gt;A）CAS第一次A，第二次A；会认为期间没有改变；解决：AtomicStampedReference，控制变量版本来保持正确性。]]></content>
      <categories>
        <category>Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Offer-Thread07]]></title>
    <url>%2F2019%2F09%2F04%2FOffer-Thread07%2F</url>
    <content type="text"><![CDATA[剑指Offer-07Java多线程与并发-原理synchronized线程安全问题的主要诱因 存在共享数据（也称临界资源） 存在多条线程共同操作这些共享数据 解决问题的根本方法： 同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再对共享数据进行操作。 互斥锁的特性： 互斥性：在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程的协调机制，这样在同一时间只有一个线程对需要同步的代码块（复合操作）进行访问。互斥性也称为操作的原子性。 可见性：必须确保在锁被释放之前，对共享变量所做的修改 ，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作，从而引起不一致。 synchronized锁的不是代码，锁的是对象 根据获取锁的分类：获取对象锁和获取类锁 获取对象锁的两种用法: 同步代码块（synchronized(this),synchronized(类实例对象)），锁是小括号（）中的实例对象。 同步非静态方法（synchronized method），锁是当前对象的实例对象 同一个类不同对象的对象锁是互不干扰的。 获取类锁的两种方法： 同步代码块（synchronized（类.class）），锁是小括号()中的类对象（Class对象） 同步静态方法（synchronized static method），锁是当前对象的类对象（class对象） 同一个类的类锁是依然按照顺序执行。 同一个类的类锁和对象锁是互不干扰的 对象锁和类锁的总结： 1.有线程访问对象的同步代码块时，另外的线程可以访问该对象的非同步代码块。 2.若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象的同步代码块的线程会被阻塞。 3.若锁住的是同一个对象，一个线程在访问对象的同步方法时，另一个访问对象同步方法的线程会被阻塞。 4.若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象同步方法的线程会被阻塞。 5.同一个类的不同对象的对象锁互不干扰 6.类锁由于也是一种特殊的对象锁，因此表现和上述的1.2.3.4一致，而由于一个类只有一把对象锁，所以同一个类的不同对象使用类锁将会是同步的。 7.类锁和对象锁互不干扰 synchronized底层实现原理实现synchronized的基础 Java对象头 Monitor 对象在内存中的布局：对象头、实例数据、对齐填充 对象头的结构： 虚拟机位数 头对象结构 说明 32/64 bit Mark Word 默认存储对象的hasCode，分代年龄，锁类型，锁标志位等信息，实现轻量级锁和偏向锁的关键 32/64 bit Class Metadata Address 类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的数据 Monitor: 每个Java对象天生自带了一把看不见的锁 C++实现的 线程对象进入_EntryList方法，获取到线程后，进入_owner方法,将owner设置为当前线程，并且count+1，线程调用wait方法时，进入waitSet方法，owner变为null，count-1。 什么是重入： 从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，就属于重入。请求将会成功。 为什么开始对synchronized嗤之以鼻 早期版本中，synchronized属于重量级锁，依赖于Mutex Lock实现 线程之间的切换需要从用户态转换到核心态，开销大 Java6以后，synchronized性能得到了很大提升。 Adaptive Spinning Lock Eliminate Lock Coarsening Lightweight Locking Biased Locking 更高效的共享数据，解决竞争问题，提高效率 自旋锁与自适应自旋锁 自旋锁： 许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得 通过让线程执行忙循环（类似于while（true））等待锁的释放，不让出CPU 缺点：若锁被其他线程长时间占用，会带来许多性能上的开销。 可用PreBlockSpin修改 自适应自旋锁： 自旋的次数不再固定 由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定 锁消除： 更彻底的优化： JIT编译时，对运行上下文进行扫描，去除不可能存在竞争的锁（提升程序的性能） 锁粗化： 如果存在一系列操作对同一个对象反复加锁或减锁 另一种极端： 通过扩大加锁的范围，避免反复加锁或解锁 synchronized的四种状态： 无锁、偏向锁、轻量级锁、重量级锁 ————-&gt;锁膨胀的方向—————&gt; 偏向锁： 减少同一线程获取锁的代价 大多数情况下，锁不存在多线程竞争，总是由同一线程多次获得 核心思想：如果一个线程获得了锁，那么锁就进入偏向模式，此时MarkWord的结构也变为偏向锁结构，当该线程再次请求锁时，无需再做任何同步操作,即获取锁的过程只需要检查MarkWord的锁标记位为偏向锁以及当前线程ID等于MarkWord的ThreadID即可，这样就省去了大量有关锁申请的操作。 不适合用于锁竞争比较激烈的多线程场合。 轻量级锁： 轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程进入锁争用的时候，偏向锁就会升级为轻量级锁。 适应的场景：线程交替执行同步块 若存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。 锁的内存语义：当线程释放锁时，Java内存模型会把线程对应的本地内存中的共享刷新到主内存中； 而当线程获取锁时，Java内存模型会把该线程对应的本地内存置于无效，从而使得被监视保护的临界区代码必须从主内存中读取共享变量。 Synchronized底层实现原理2 需要重复理解synchronized和ReentrantLock的区别ReentrantLock(再入锁) 位于java.util.concurrent.locks包 和CountDownLatch、FutureTask、Semaphore一样基于AQS实现 能够实现比synchronized更细粒度的控制，如控制fairness 调用lock()之后，必须调用unlock()释放锁 性能未必比synchronized高，并且也是可重入的 ReentrantLock公平性的设置 ReentrantLock fairLock = new ReentrantLock(true); 参数为true时，倾向于将锁赋予等待时间最久的线程 公平锁：获取锁的顺序按先后调用lock方法的顺序（慎用） 非公平锁：抢占的顺序不一定，看运气 synchronized是非公平锁 ReentrantLock将锁对象化 判断是否有线程，或者某个特定线程，在排队等待获取锁 带超时的获取锁的尝试 感知有没有获取到锁 是否能将wait\notify\notifyAll对象化 java.util.concurrent.locks.Condition 区别总结： synchronized是关键字，ReentrantLock是类 ReentrantLock可以对获取锁的等待时间进行设置，避免死锁 ReentrantLock可以获取各种锁的信息 ReentrantLock可以灵活地实现多路通知 机制：sync操作MarkWord，lock调用Unsafe类的park()方法]]></content>
      <categories>
        <category>Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Offer-Thread06]]></title>
    <url>%2F2019%2F09%2F02%2FOffer-Thread06%2F</url>
    <content type="text"><![CDATA[剑指Offer-06Java多线程与并发Java线程知识考点进程和线程的区别 进程时资源分配的最小单位，线程是CPU调度的最小单位 所有与进程相关的资源，都被记录在PCB中 进程是抢占处理机的调度单位；线程属于某个进程，共享其资源 线程只由堆栈寄存器、程序计数器和（线程控制表）TCB组成 PCB记录描述信息、控制信息、资源信息（程序段和数据集）、CPU现场 线程不能看作独立应用，而进程可以看作独立应用 进程有独立的地址空间，相互不影响，线程只是进程的不同执行路径 线程没有独立的地址空间，多进程的程序比多线程程序健壮 进程的切换比线程的切换开销大 Java进程和线程的关系 Java对操作系统提供的功能进行封装，包括进程和线程 运行一个程序会产生一个进程，进程至少包含一个线程 每个程序对应一个JVM实例，多个线程共享JVM里的堆 Java采用单线程编程模型，程序会自动创建主线程 主线程可以创建子线程，原则上要后于子线程完成执行 Thread中的start和run方法的区别 start（） -&gt; JVM_StartThread(创建子线程) -&gt; thread_entry（调用run方法） -&gt; run() 调用start（）方法会创建一个新的子线程并启动 run（）方法只是Thread的一个普通方法的调用 Thread和Runnable的区别（待验证） Thread是实现了Runnable接口的类，使得run支持多线程 因类的单一继承原则，推荐多使用Runnable接口，便于给普通类附上多线程的特性 如何给run()方法传参（待验证） 构造函数传参 成员变量传参 回调函数传参 如何实现处理线程的返回值（待验证） 主线程等待法 使用Thread类的join()阻塞当前的线程以等待子线程处理完毕 通过Callable接口实现：通过FutureTask 或者 线程池获取 线程的状态 新建（New）：创建后尚未启动的线程的状态 运行（Runnable）：包含running状态的线程（在可运行线程中等待被线程选中）、ready状态的线程(位于线程池中，获得时间运行后，变为running状态的线程) 无限期等待（Waiting）：不会被分配CPU执行时间，需要显示被唤醒 没有设置Timeout参数的Object.wait()方法 没有设置Timeout参数的Thread.join()方法 LockSupport.park()方法 限期等待（Timed Waiting）：在一定时间后会由系统自动唤醒 thread.sleep()方法 设置了Timeout参数的Object.wait()方法 设置了Timeout参数的Thread.join()方法 LockSupport.parkNanos（）方法 LockSupport.parkUntil（）方法 阻塞（Blocked）：等待获取排它锁 结束（Terminated）：已终止线程的状态，线程已经结束执行 run(),main()方法结束，或者有异常抛出 sleep和wait的区别 sleep是Thread类的方法，wait是Object类的方法 sleep()方法可以在任何地方使用 wait()方法只能在synchronized方法或synchronized块中使用 Thread,sleep只会让出CPU，不会导致锁行为的改变 Object.wait不仅让出CPU，还会释放已经占有的同步资源锁 notify和notifyAll的区别两个概念： 锁池EntryList：假设线程A已经拥有了某个对象（不是类）的锁，而其他线程B、C想要调用这个对象的某个synchronized方法（或者块），由于B、C线程在进入对象的sunchronized方法之前必须先获得该对象锁的拥有权，而恰巧该对象的锁目前正在被线程A所占用，此时B、C线程就会被阻塞，进入一个地方去等待锁的释放，这个地方便是该对象的锁池。 等待池WaitSet：假设线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁，同时线程A就进入到了该对象的等待池中，进入到等待池中的线程不会去竞争该对象的锁。 notifyAll会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会 notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会 yield当调用Thread.yield()函数时，会给线程调度器一个当前线程愿意让出CPU使用的暗示，但是线程调度器可能会忽略这个暗示。（调度器也可能让线程继续执行） 如何中断线程已经被抛弃的方法：stop(); suspend();resume(); eg:A突然终止线程B，不知道B的执行情况，可能无法清理。B马上释放锁，可能会造成线程不同步 interrupt()：通知线程应该中断了 如果线程处于被阻塞状态，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常 如果线程处于正常活动状态，那么会将该线程的中断标志设置为true。被设置中断标志的线程将继续正常运行，不受影响。 需要被调用的线程配合中断 在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程。 线程状态以及状态之间的转换 见牛客笔记堆栈寄存器、程序计数器和（线程控制表）TCB组成 PCB记录描述信息、控制信息、资源信息（程序段和数据集）、CPU现场 线程不能看作独立应用，而进程可以看作独立应用 进程有独立的地址空间，相互不影响，线程只是进程的不同执行路径 线程没有独立的地址空间，多进程的程序比多线程程序健壮 进程的切换比线程的切换开销大 Java进程和线程的关系 Java对操作系统提供的功能进行封装，包括进程和线程 运行一个程序会产生一个进程，进程至少包含一个线程 每个程序对应一个JVM实例，多个线程共享JVM里的堆 Java采用单线程编程模型，程序会自动创建主线程 主线程可以创建子线程，原则上要后于子线程完成执行 Thread中的start和run方法的区别 start（） -&gt; JVM_StartThread(创建子线程) -&gt; thread_entry（调用run方法） -&gt; run() 调用start（）方法会创建一个新的子线程并启动 run（）方法只是Thread的一个普通方法的调用 Thread和Runnable的区别（待验证） Thread是实现了Runnable接口的类，使得run支持多线程 因类的单一继承原则，推荐多使用Runnable接口，便于给普通类附上多线程的特性 如何给run()方法传参（待验证） 构造函数传参 成员变量传参 回调函数传参 如何实现处理线程的返回值（待验证） 主线程等待法 使用Thread类的join()阻塞当前的线程以等待子线程处理完毕 通过Callable接口实现：通过FutureTask 或者 线程池获取 线程的状态 新建（New）：创建后尚未启动的线程的状态 运行（Runnable）：包含running状态的线程（在可运行线程中等待被线程选中）、ready状态的线程(位于线程池中，获得时间运行后，变为running状态的线程) 无限期等待（Waiting）：不会被分配CPU执行时间，需要显示被唤醒 没有设置Timeout参数的Object.wait()方法 没有设置Timeout参数的Thread.join()方法 LockSupport.park()方法 限期等待（Timed Waiting）：在一定时间后会由系统自动唤醒 thread.sleep()方法 设置了Timeout参数的Object.wait()方法 设置了Timeout参数的Thread.join()方法 LockSupport.parkNanos（）方法 LockSupport.parkUntil（）方法 阻塞（Blocked）：等待获取排它锁 结束（Terminated）：已终止线程的状态，线程已经结束执行 run(),main()方法结束，或者有异常抛出 sleep和wait的区别 sleep是Thread类的方法，wait是Object类的方法 sleep()方法可以在任何地方使用 wait()方法只能在synchronized方法或synchronized块中使用 Thread,sleep只会让出CPU，不会导致锁行为的改变 Object.wait不仅让出CPU，还会释放已经占有的同步资源锁 notify和notifyAll的区别 两个概念： 锁池EntryList：假设线程A已经拥有了某个对象（不是类）的锁，而其他线程B、C想要调用这个对象的某个synchronized方法（或者块），由于B、C线程在进入对象的sunchronized方法之前必须先获得该对象锁的拥有权，而恰巧该对象的锁目前正在被线程A所占用，此时B、C线程就会被阻塞，进入一个地方去等待锁的释放，这个地方便是该对象的锁池。 等待池WaitSet：假设线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁，同时线程A就进入到了该对象的等待池中，进入到等待池中的线程不会去竞争该对象的锁。 notifyAll会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会 notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会 yield 当调用Thread.yield()函数时，会给线程调度器一个当前线程愿意让出CPU使用的暗示，但是线程调度器可能会忽略这个暗示。（调度器也可能让线程继续执行） 如何中断线程 已经被抛弃的方法：stop(); suspend();resume(); eg:A突然终止线程B，不知道B的执行情况，可能无法清理。B马上释放锁，可能会造成线程不同步 interrupt()：通知线程应该中断了 如果线程处于被阻塞状态，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常 如果线程处于正常活动状态，那么会将该线程的中断标志设置为true。被设置中断标志的线程将继续正常运行，不受影响。 需要被调用的线程配合中断 在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程。 线程状态以及状态之间的转换 见牛客笔记]]></content>
      <categories>
        <category>Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Offer-GC05]]></title>
    <url>%2F2019%2F09%2F02%2FOffer-GC05%2F</url>
    <content type="text"><![CDATA[剑指Offer-05GC—垃圾回收机制GC相关的面试题Object的finalize()方法的作用是否与C++的析构函数作用相同（待验证） 与C++的析构函数不同，析构函数调用确定，而他不是确定的 将未被引用的对象放置于F-Queue队列 方法执行随时可能会被终止 给予对象最后一次重生机会 当执行System.gc的时候，运行finalize方法，将f对象的值传给finalization，获得重生 Java中的强引用，软引用，弱引用，虚引用有什么用 强引用（Strong Reference）： 不会被回收，对象一般状态，JVM停止运行时终止 最普遍的引用：Object obj = new Object（）； 抛出OutOfMemoryError终止程序也不会回收具有强引用的对象。 通过将对象设置为null来弱化引用，使其被回收。 软引用（Soft Reference）： 内存不足时被回收，用于对象缓存，内存不足时终止 对象处在有用但非必须的状态 只有当内存空间不足时，GC会回收该引用的对象的内存 可以用来实现高速缓存 String str = new String(“abc”);//强引用 SoftReference softRef = new SoftRefence(str);//软引用 弱引用（Weak Reference）： 垃圾回收时被回收，用于对象缓存，gc运行后终止 非必需的对象，比软引用更弱一些 GC时会回收 被回收的概率不大，因为GC线程优先级比较低适用于引用偶尔被使用且不影响垃圾收集的对象 String str = new String（“abc”）； WeakReference abcWeakRef = new eakReferencestr. 虚引用（PhantomReference）： 用于标记、哨兵 不会决定对象的生命周期 任何时候都可能被垃圾收集器回收 跟踪对象被垃圾收集器回收的活动，有哨兵作用 必须和引用队列ReferenceQueue联合使用 String str = new String(“abc”); ReferenceQueue queue = new ReferenceQueue(); PhantomReference ref = new PhantomReference(str,queue); 引用队列（ReferenceQueue）（待验证） 无实际存储结构，存储逻辑依赖于内部节点之间的关系来表达 存储关联的且被GC的软引用，弱引用以及虚引用]]></content>
      <categories>
        <category>Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Offer-GC04]]></title>
    <url>%2F2019%2F09%2F02%2FOffer-GC04%2F</url>
    <content type="text"><![CDATA[剑指Offer-04GC—垃圾回收机制垃圾回收之标记算法对象被判定为垃圾的标准：没有被其他对象引用 引用技术算法：判断对象的引用数量 通过判断对象的引用数量来决定对象是否可以被回收 每个对象实例都有一个引用计数器，被引用则+1，完成引用-1 （ 当对象超出生命周期或者被设置为新值时） 任何引用计数为0的对象实例可以被当作垃圾收集 优点：执行效率高，程序执行受影响较小 缺点：无法检测出循环引用的情况，导致内存泄露 可达性分析算法：通过判断对象的引用链是否可达来决定对象是否可以被回收（从GC Root开始，直接或间接引用的对象保留，没有引用GCRoot的对象被回收） 可以作为GC Root的对象 虚拟机栈中引用的对象（栈帧中的本地变量表） eg：String s = new String（“黄山奇”）； new出来的String就是GC Root。 方法区中的常量引用的对象 方法区中的类静态属性引用的对象 本地方法栈中JNI（Native方法）的引用对象 活跃线程的引用对象 谈谈垃圾回收算法标记-清除算法（Mark and Sweep） 标记：从根集合开始扫描，对存活的对象进行标记（可达性分析算法） 清除：对堆内存从头到尾进行线性遍历，回收不可达对象内存 缺点：清除后不会对内存进行排序，会产生大量碎片，如果有超过间隔内存的内容，会一直尝试清除内存，直到有足够的空间为止。 适用于老年代（存活率高） 复制算法（Copying） 分为对象面和空闲面 对象在对象面上创建 存活的对象被从对象面复制到空闲面 将对象面所有对象内存清除 适用于对象存活率低的场景 eg：年轻代（一般只有10%存活） 解决碎片化的问题 顺序分配内存，简单高效 标记-整理算法（Compacting） 标记：从根集合进行扫描，对存活的对象进行标记 清除：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收 避免了内存的不连续性 不用设置两块内存互换 适用于存活率高的场景 eg：老年代 分代收集算法（Generational Collector） 垃圾回收算法的组合拳 按照对象生命周期的不同划分区域以采用不同的垃圾回收算法 目的：提高JVM的回收效率 分代收集算法GC的分类： Minor GC:发生在年轻代中的垃圾收集工作，采用复制算法 Full GC：Full GC比Minor GC慢，但执行频率低 ​ Stop-the-World JVM由于要执行GC而停止了应用程序的执行 任何一种GC算法中都会发生 多数GC优化通过减少Stop-the-World发生的时间来提高程序性能 ​ Safepoint 分析过程中对象引用关系不会发生变化的点 产生Safepoint的地方：方法调用；循环跳转；异常跳转等； 安全点要适中：太少增加GC等待时间，太多增加负荷 年轻代：尽可能快速的收集掉那些生命周期短的对象。所有java对象出生地，java对象申请的内存，以及存放 常用的调忧参数 -XX：SurvivorRatio：Eden和Survivor的比值，默认为8：1 -XX：NewRatio：老年代和新生代内存大小比例 -XX：MaxTenuringThreshold：对象从年轻代晋升到老年代GC次数的最大值 分为：Eden区 Survivor-from区 Survivor-to区 大小比例为8：1：1 生成的对象先放在Eden和from，然后将存活的对象放在to区，删除其他区。 对象如何晋升到老年代 经历一定Minor次数依然存活的对象 Survivor区中存放不下的对象 新生成的大对象（-XX：+PretenuerSizeThreshold） 老年代：存放生命周期较长的对象，占2/3的堆空间（ 年轻1/3） 触发Full GC的条件： 老年代空间不足 永久代空间不足（jdk8以后没有永久代了，不成立） CMS GC时出现promotion failed，concurrent mode failure Minor GC晋升到老年代的平均大小大于老年代的剩余空间 调用System.gc(),（提醒该回收了，未必回收） 使用RMI来进行RPC或管理JDK应用，每小时执行次Full GC promotion：新生代放不下时，放到老年代，老年代也放不下 concurrent：执行CMS GC时，新生代也要放到老年代中，此时老年代不足 常见的垃圾收集器JVM的运行模式：Server、Client Client启动快，Server启动慢，但是运行稳定后，Server比Client运行快。因为Server用重量级的JVM，优化好。 垃圾收集器之间的联系： 年轻代常见的垃圾收集器 Serial收集器（-XX：+UseSerialGC,复制算法）：Java最基本，历史最悠久 单线程收集，进行垃圾收集时，必须暂停所有工作线程。 简单高效，Client模式下的默认的年轻代收集器 ParNew收集器（-XX：+UserParNewGC，复制算法） 多线程收集，其余的行为、特点和Serial收集器一样 单核执行效率不如Serial，在多核下执行才有优势 Parallel Scave收集器（-XX：+UseParallelGC，复制算法） 吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间） 高吞吐量可以高效率利用CPU时间，更快完成任务 比起关注用户线程停顿时间，更关注系统的吞吐量 在多核下执行才有优势，Server模式下默认的年轻代收集器 老年代常见的垃圾收集器：&lt;/u Serial Old收集器（-XX：+UseSerialOldGC,标记-整理算法） 单线程收集，进行垃圾收集时，必须暂停所有工作线程。 简单高效，Client模式下的默认的老年代收集器 Parallel Old收集器（-XX：+UseParallelOldGC，标记-整理算法） 多线程、吞吐量优先 CMS收集器（-XX：+UseConcMarkSweepGC，标记-清除算法） 能做到垃圾回收线程与用户线程几乎同时工作，可能会产生大量的碎片 运行过程： 初始标记：stop-the-world 并发标记：并发追溯标记，程序不会停顿 并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象 重新标记：暂停虚拟机，扫描CMS堆中的剩余对象（stop-the-world） 并发清理：清理垃圾对象，程序不停顿 并发重置：重置CMS收集器的数据结构 G1收集器（-XX:+UseG1GC，复制+标记-整理算法） 将整个Java堆内存划分为多个大小相等的Region 年轻代和老年代不在物理隔离 Garbage First收集器的特点 并发和并行 分代收集 空间整合 可预测的停顿 JDK11：Epsilon GC和ZGC CMS不能和ParallelScavenge、G1组合使用 因为后两者没有使用传统的GC框架，都是独立实现的]]></content>
      <categories>
        <category>Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Offer-JVM03]]></title>
    <url>%2F2019%2F09%2F02%2FOffer-JVM03%2F</url>
    <content type="text"><![CDATA[剑指Offer-03Java的理解—JVM 平台无关性GC 语言特性 面向对象 类库 异常处理 Java的内存模型（RunTime Data Area）内存简介： 逻辑地址→分段管理机制→线性地址→分页管理机制→物理地址 程序运行时不断地再逻辑地址和物理地址之间进行映射，找到相关的数据和指令执行。 受限于可寻址地址空间，可寻址地址空间受到处理器位数限制： 32位处理器：2^32 可寻址范围 64位处理器：2^64可寻址范围 地址空间的划分： 内核空间(操作系统程序和C运行时的空间) 用户空间(java实际运行空间) 从线程角度看模型结构： 线程私有：程序计数器、虚拟机栈、本地方法栈 线程共享：MetaSpace、Java堆（常量池+堆） 程序计数器：内存空间较小 当前线程所执行的字节码行号指示器（逻辑指示器） 改变计数器的值来选取下一条需要执行的字节码指令(循环、跳转、异常恢复) 和线程是一对一的关系即“线程私有” 对Java方法计数，如果是Native方法则计数器的值为Undefined 不会发生内存泄漏 Java虚拟机栈 Java方法执行的内存模型 包含多个栈（每个方法运行时创建一个栈帧，存储了局部变量表、操作栈、动态连接、返回地址,从入栈到出栈的过程） ​ 局部变量表：包含方法执行过程中的所有变量 ​ 操作数栈：入栈、出栈、复制、交换、产生消费变量 递归为什么会引发java.lang.StackOverflowError异常： 每次调用自身，就会形成一个栈帧。 保存当前方法的栈帧状态，放到虚拟机栈中，虚拟机栈是固定的，递归过深，超出虚拟栈深度。 要么限制递归次数，要么for循环 虚拟机栈过多会引发java.lang.OutOfMemoryError异常 本地方法栈： 与虚拟机类似，主要作用与标注了native的方法 元空间(MetaSpace)与永久代(PermGen)的区别: 存储Class的相关信息，class的methed、Field等 元空间使用本地内存，永久代使用JVM内存（MS内存多） 元空间没有常量池，在JDK7中被移动到堆中。 MetaSpace相比PermGen的优势： 字符串常量池在永久代中，容易出现性能问题和内存溢出 类和方法的信息大小难确定，给永久代的大小指定带来困难 永久代会为GC带来不必要的复杂性 Java堆（Heap）： 对象实例的分配区域 GC管理的主要区域 从存储角度看模型结构： JVM三大性能调忧参数-Xms -Xmx -Xss的含义： 在java指令调用程序时，可以通过这三个指令区调整堆和线程占堆栈的大小 -Xss：规定了每个线程虚拟机栈（堆栈）的大小 -Xms：堆得初始值 -Xmx：堆能达到的最大值 通常将Xms和Xmx设置成一样的，当扩容时容易发生抖动，影响运行 Java内存模型中堆和栈的区别: 内存分配策略： 静态存储：编译时确定每个数据目标在运行时的存储空间需求。固定不变。 栈式存储：动态存储分配。数据区需求在编译时未知，运行时模块入口前确定。 堆式存储：编译时或运行时模块入口都无法确定，动态分配。 堆和栈之间的联系：引用对象、数组时，栈里定义变量保存堆中目标的首地址。 管理方式：栈自动释放，堆需要GC（垃圾回收器） 空间大小：栈比堆小 碎片相关：栈产生的碎片远小于堆 分配方式：栈支持静态和动态分配，堆仅动态分配 效率：栈的效率比堆高 堆采用双向链表的方式，较复杂，但堆得灵活度高于栈 JDK6和JDK6以后的intern()方法的区别： 12String s = new String(&quot;a&quot;);s.intern(); JDK6：当调用intern方法时，如果字符串常量池先前已创建出改字符串对象，则返回该字符串的引用。否则，将此字符串对象添加到字符串常量池中，并返回该引用。 JDK6+：当调用intern方法时，如果字符串常量池先前已创建出该字符串对象，则返回该字符串的引用。否则，如果该字符串对象已经存在于Java堆中，则将堆中对此对象的引用添加到字符串常量池中，并返回引用。如果堆中不存在，则在池中创建该字符串并返回引用。 之前 说常量池在JDK7之前在永久代中，永久代在JVM内存，内存小，当永久代内存达到饱和，则常量池也Over]]></content>
      <categories>
        <category>Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Offer-JVM02]]></title>
    <url>%2F2019%2F09%2F02%2FOffer-JVM02%2F</url>
    <content type="text"><![CDATA[剑指Offer-02Java的理解—JVM 平台无关性GC 语言特性 面向对象 类库 异常处理 Compile Once，Run Anywhere如何实现 (Java是如何实现平台无关的)java分为： 编译时：javac 编译java的源码，即将源码转换为字节码，并存放到.class文件运行时：.class文件，JVM进行解析，转换成特定平台的执行指令。（机器码） javap -c 从.class到可执行程序，对代码进行反汇编。 答：Java源码首先被编译成字节码，再由不同平台的JVM进行解析。Java语言再不同的平台上运行时不需要进行重新编译。Java虚拟机在执行字节码的时候，把字节码转换成具体平台上的机器指令。 为什么JVM不直接将源码解析成机器码去执行准备工作：每次执行都需要各种检查。对语法等需要重复检查，影响性能。 兼容性：也可以将别的语言解析成字节码。 JVM如何加载.class文件 JVM的存储空间即内存（以下四项也是JVM的架构） Class Loader：依据特定格式，加载class文件到内存 Execution Engine：对命令进行解析（解析class文件中的字节码） Native Interface：融合不同开发语言的原生库为Java所用 ​ (通过Class.forname方法） Runtime Data Area：JVM内存空间结构模型，程序加载到这里运行 什么是反射Java反射机制： 在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法； 对于任意一个对象，都能够调用它的任意方法和属性； 这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 反射的例子（待验证） 例子待定 ClassLoader(类加载器)类从编译到执行的过程： 编译器将Robot.java源文件编译为Robot.class字节码文件 ClassLoader将字节码转换为JVM中的Class对象 JVM利用Class对象实例化为Object对象 什么是ClassLoader： 工作在Class装载的加载阶段，主要作用是从系统外部获得Class二进制数据流。所有的Class都是由ClassLoader进行加载的。它先将Class文件里的二进制数据流装载进系统，然后交给Java虚拟机进行连接、初始化操作。 ClassLoader的种类： BootStrapClassLoader：C++编写，加载核心库java.* ExtClassLoader：Java编写，加载扩展库javax.* AppClassLoader：java编写，加载程序所在目录（Class.path） CustomClassLoader：Java编写，定制化加载，自定义加载 类加载器的双亲委派机制： 👆 查看是否加载过 尝试Load JRE\lib\rt.jar 或者 ​ Bootstrap ClassLoader Xbootclasspath选项指定的jar包 👇 👆 查看是否加载过 尝试Load JRE\lib\ext*.jar 或 ​ Extension ClassLoader Djava.ext.dirs指定目录下的jar包 👇 👆 查看是否加载过 尝试load ClassPath 或 Djava. ​ App ClassLoader class.path指定目录下的类和jar包 👇 👆 查看是否加载过 通过java.lang.ClassLoader的子类 ​ Custom ClassLoader 自定义加载的class ​ 👇 ​ 都没有类文件，抛出ClassNotFoundException 为什么要使用双亲委派机制加载类： 避免多份同样的字节码的加载。 eg：比如A调用过z类，B也要调用z类时，逐层查看loader是否在加载过z类。 LoadClass和forName的区别类的加载方式： 隐式加载：new（无需调用new instance方法即可创建实例，还支持带参数的构造器生成对象实例） 显示加载：loadClass,forname等 （获得Class后，需要调用class的new instance方法，创建对象的实例，不支持参数，需通过反射才能调用参数） 类的装载过程： 加载：通过ClassLoader加载class文件字节码，生成class对象。 链接： 校验：检查加载的class的正确性和安全性 准备：为类变量分配存储空间并设置类变量初始值（static） 解析：JVM为常量池内的符号引用转换为直接（可选） 初始化：执行类变量赋值和静态代码块 Class.forName得到的class是初始化完成的 loadClass得到的class是还没有链接的 什么时候用到loadClass? eg:在Spring IOC中用了大量的延迟加载加快编译速度，而用loadClass读取Bean文件时，不需要加载类的代码，加快了速度，代码留到以后用到该类时再编译。]]></content>
      <categories>
        <category>Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Offer-Net01]]></title>
    <url>%2F2019%2F09%2F02%2FOffer-Net01%2F</url>
    <content type="text"><![CDATA[剑指Offer-01 长期支持JDK8和JDK11 网络知识考点 偏向于理论 OSI开放式互联参考模型 1234&gt; 市面存在四、五、七层协议&gt; &gt; 国际：七层协议&gt; 第一层：物理层 发送7，接收1 链路层 转换为比特流 首先解决两台物理机之间的通信需求：发送比特流 主要定义了物理设备的标准：网线类型、光纤的接口等….. 传输比特流，即0101的二进制码转换为电流强弱，令一台机器将电流转换为二进制。（数模转换与模数转换） 第二层：数据链路层 链路层 传输比特流中，可能出现传输不完整的可能。 定义了如何格式化数据以及控制物理数据的访问。错误检测和纠正。 将比特数据组成了帧，交换机在这一层对帧解码，根据信息传送给正确的接收方。 第三层：网络层 发送5，接收3 网络层 加入（解除）IP首部 如何找到目标节点以及最佳路径。 将网络地址转换成对应的物理地址。通过堵塞程度、节点数量等调节决定最佳路径。 路由器从属于网络层。 TCP/IP协议。 第四层：传输层 发送4，接收4 传输层 ######数据切分为为IP数据包。 对大型数据进行切分，如果丢失某一段数据，传输层解决。 对每段数据安排序列号，接收端可以按照顺序重组。 TCP UDP协议 第五层：会话层 发送3，接收5 应用层 不能每一次通信都要进行以上的环节，麻烦。 并且不同机器上的用户之间建立会话。 所以要建立和管理应用程序之间的通信。 第六层：表示层 发送2，接收6 应用层 不同系统之间可能不能运行。 将数据按照网络能理解的方案进行格式化。 格式化根据网络类型不同而不同。 第七层：应用层 发送1，接收7 应用层 在数据中加入（解除）TCP首部，形成http报文 发送方知道发送的长度、消息头。 接收方不知道。 应用层规定数据用固定的消息头发送消息。 1OSI的实现：TCP/IP（多数情况为协议群的统称，包括很多跟TCP和IP协议有关的协议）]]></content>
      <categories>
        <category>Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL_04]]></title>
    <url>%2F2019%2F05%2F19%2FMySQL-04%2F</url>
    <content type="text"><![CDATA[MYSQL[TOC] 视图(了解) 虚表实表：create table 创建出来的表 从用户角度来看，一个视图是从一个特定的角度来查看数据库中的数据 。从数据库系统内部来看，一个视图是由SELECT语句组成的查询定义的虚拟表 。从数据库系统内部来看，视图是由一张或多张表中的数据组成的，从数据库系统外部来看，视图就如同一张表 一样，对表能够进行的一般操作都可以应用于视图，例如查询，插入，修改，删除操作等。 从虚表中增删改数据，对实表的影响是无法预知的，所以虚表仅用查询，不允许增删改 2、视图的用途 筛选表中的行(可以将指定的列通过视图释放出来，也可以隐藏一些比较隐私的列) 防止未经许可的用户访问敏感数据(视图权限) 降低数据库的复杂程度（视图体现的是逻辑，也是业务） 将多个物理数据库抽象为一个逻辑数据库（业务） 使用视图可以给用户和开发人员带来很多好处。具体为： A. 对最终用户的好处 （ 1 ）结果更容易理解 创建视图时，可以将列名改为有意义的名称，使用户更容易理解列所代表的内容。在视图中修改列名不会影响基表的列名。 （ 2 ）获得数据更容易 很多人对 SQL 不太了解，因此对他们来说创建对多个表的复杂查询很困难。可以通过创建视图来方便用户访问多个表中的数据。 B. 对开发人员的好处 （ 1 ）限制数据检索更容易 开发人员有时需要隐藏某些行或列中的信息。通过使用视图，用户可以灵活地访问他们需要的数据，同时保证同一个表或其他表中的其他数据的安全性。要实现这一目标，可以在创建视图时将要对用户保密的列排除在外。 （ 2 ）维护应用程序更方便 ​ 调试视图比调试查询更容易。跟踪视图中过程的各个步骤中的错误更为容易，这是因为所有的步骤都是视图的组成部分 从一个或者多个表或视图中导出的虚拟表，其结构和数据是建立在对表的查询基础上的。 理论上它可以像普通的物理表（实表）一样使用，例如增、删、改、查等，修改视图中的数据实际上是修改原始数据表。因为修改视图有许多限制，所以在实际开发中一般视图仅做查询使用。 123create view v_detail as select * from table 实表的改变，会实时反映到虚表上 索引（了解） index用途:我们对数据查询及处理速度已成为衡量应用系统成败的标准，而采用索引来加快数据处理速度通常是最普遍采用的优化方法。 索引是什么:数据库中的索引类似于一本书的目录，在一本书中使用目录可以快速找到你想要的信息，而不需要读完全书。在数据库中，数据库程序使用索引可以定向到表中的数据，而不必扫描整个表。书中的目录是一个字词以及各字词所在的页码列表，数据库中的索引是表中的值以及各值存储位置的列表。 索引的利弊：查询执行的大部分开销是I/O，使用索引提高性能的一个主要目标是避免全表扫描，因为全表扫描需要从磁盘上读取表的每一个数据页，如果有索引指向数据值，则查询只需要读少数次的磁盘就行啦。所以合理的使用索引能加速数据的查询。但是索引并不总是提高系统的性能，带索引的表需要在数据库中占用更多的存储空间，同样用来增删数据的命令运行时间以及维护索引所需的处理时间会更长。所以我们要合理使用索引，及时更新去除次优索引。 系统会为primary key和unique自动创建索引 是否适合创建索引的列： 该列数据是否经常变化，如果经常变化，不适合创建索引 查询使用频繁的列，适合创建索引 拓展阅读 索引建立原则参考 创建索引语法 123CREATE INDEX可对表增加普通索引或UNIQUE索引。CREATE INDEX index_name ON table_name (column_list)CREATE UNIQUE INDEX index_name ON table_name (column_list) 12345# 对course表的cname列创建索引，索引的名字为index_cnamecreate index index_cname on course(cname);# 从course表中将索引index_cname删除drop index index_cname on course; ##流程控制函数 CASE-WHEN-THEN-ELSE-END CASE WHEN 条件1 THEN 结果1 [WHEN 条件2 THEN 结果2 …] [ELSE 最终结果] # 如果没有匹配的结果值，则返回结果为ELSE后的结果，如果没有ELSE部分，则返回值为 NULLEND 查询学生的成绩信息，学号，姓名，课程名，成绩，以及成绩的等级 90-100优秀 75-89 良好 60-75及格 60分以下不及格 12345678910select s.sno as &apos;学号&apos;,sname as &apos;姓名&apos;,cname &apos;课程名&apos;,grade &apos;成绩&apos;, case when grade&gt;=90 then &apos;优秀&apos; when grade&gt;=75 then &apos;良好&apos; when grade&gt;=60 then &apos;及格&apos; ELSE &apos;不及格&apos; END AS &apos;等级&apos; # END 表示case语句的结束 &apos;等级&apos;列的别名from student s,sc, course cwhere s.sno=sc.sno and c.cno=sc.cno 系名练习 查询学生信息，如果系名为CS，则显示计算机科学，如果系名为IS，则显示信息系统，如果系名为MA，则显示数学 12 IF IF(条件,条件为真时执行,条件为假时执行); #类似于java中的 boolean ? A : B 三目运算符 输出学生信息，如果性别为F则输出女，如果为M，则输出男 12select sno 学号,sname 姓名,if(ssex=&apos;M&apos;,&apos;男&apos;,&apos;女&apos;) as 性别,sdept 所在系from student 查询学生信息，如果系名为CS，则显示计算机科学，如果系名为IS，则显示信息系统，如果系名为MA，则显示数学 123select sno 学号,sname 姓名,if(ssex=&apos;M&apos;,&apos;男&apos;,&apos;女&apos;) as 性别,if(sdept=&apos;CS&apos;,&apos;计算机科学&apos;,if(sdept=&apos;MA&apos;,&apos;数学&apos;,&apos;信息系统&apos;)) 所在系from student IFNULL IFNULL(EXP1,EXP2) EXP1如果为空，则显示EXP2的内容，如果不为空，就显示其本身内容 查询课程的先修课，如果先修课为null，则显示无 12select cno 课程号,cname 课程名,IFNULL(CPNO,&apos;无&apos;) 先修课,ccredit 学分from course 存储过程存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。 存储过程是可编程的函数，在数据库中创建并保存，可以由SQL语句和控制结构组成。当想要在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。 语法CREATE PROCEDURE 存储过程名 (参数列表) BEGIN – 代码 END 参数 存储过程根据需要可能会有输入、输出、输入输出参数，多个参数用”,”分割开。共有三种参数类型,IN,OUT,INOUT: IN参数的值必须在调用存储过程时指定，在存储过程中可以修改该参数的值，但不能被返回 OUT该值可在存储过程内部被改变，并返回 INOUT调用时指定，并且可被改变和返回 调用 调用存储过程: CALL 存储过程名(参数列表); 删除 删除存储过程: DROP PROCEDURE 存储过程名; 实例1 输入参数有多个 定义 1234567891011DROP PROCEDURE IF EXISTS p1;# 如果存储过程p1存在则删除# 创建存储过程CREATE PROCEDURE p1(IN a INT, IN b VARCHAR(20))BEGIN select a; select b; set a=20; set b=&apos;hello world&apos;; select a; select b;END; 调用1 1call p1(10,&apos;abcd&apos;) 调用2 123456set @x=12;set @y=&apos;abc&apos;;call p1(@x,@y);select @x;select @y; @@:表示系统变量@:表示自定义变量 实例2 带有传出参数 1234567891011DROP PROCEDURE IF EXISTS p2;CREATE PROCEDURE p2(out a INT, out b VARCHAR(20))BEGIN select a; # 会输出null，参数值传不进来 select b; # 会输出null，参数值传不进来 set a=20; set b=&apos;hello world&apos;; select a; select b;END; 12345set @m=12;set @n=&apos;abc&apos;;call p2(@m,@n);select @m; # 显示存储过程中设置的值 20select @n; # 显示存储过程中设置的值 hello world 实例3 输入输出参数 1234567891011DROP PROCEDURE IF EXISTS p3;CREATE PROCEDURE p3(INOUT a INT, INOUT b VARCHAR(20))BEGIN select a; select b; set a=20; set b=&apos;hello world&apos;; select a; select b;END; 调用 123set @m=12;set @n=&apos;abc&apos;;CALL p3(@m,@n); 实例4 变量声明 123456789101112131415DROP PROCEDURE IF EXISTS p4;CREATE PROCEDURE p4(INOUT str VARCHAR(50))BEGIN # DECLARE 变量名[,...] 变量类型 [DEFAULT 默认值] # 局部变量声明必须在最上面,并且中间还不能有任何其他代码 DECLARE a VARCHAR(32); DECLARE b VARCHAR(32); DECLARE c VARCHAR(32) DEFAULT &apos;hello&apos;; select sno,sname into a,b from student where sno=&apos;200215121&apos;; set str=CONCAT(a,b,c);END; 调用 123set @s=&apos;&apos;;CALL p4(@s);select @s; 实例5 IF-THEN–ELSEIF-THEN…–ELSE-END IF 12345678910111213141516DROP PROCEDURE IF EXISTS p5;CREATE PROCEDURE p5(IN stu VARCHAR(10), IN cou INT)BEGIN DECLARE DEG INT; SELECT GRADE INTO DEG FROM sc WHERE SNO=stu and cno=cou; IF DEG&gt;90 THEN SELECT &apos;优秀&apos;; ELSEIF DEG&gt;85 THEN SELECT &apos;良好&apos;; ELSEIF DEG&gt;60 THEN SELECT &apos;及格&apos;; ELSE select &apos;不及格&apos;; END IF;END; 调用 1CALL p5(&apos;200215121&apos;,1) 实例6 [循环名:] LOOP 要循环的代码END LOOP [循环名] LEAVE 循环名:这个语句被用来退出任何被标注的流程控制构造 (跳出某个循环)ITERATE 循环名:跳出某个循环,进入下一次循环 创建表，通过存储过程向表中插入100条数据 123create table t1(id int PRIMARY key auto_increment) 存储过程 1234567891011121314create PROCEDURE p6()BEGINDECLARE i INT DEFAULT 1; sta:LOOP IF i&gt;100 THEN LEAVE sta; END IF; INSERT into t1 VALUES(null); SET i = i + 1; END LOOP sta;end; 调用 1call p6(); 1234# 清空表中的数据：删除表，重建表，可知id自增长序列，从开开始TRUNCATE TABLE t1;# 清空表中的数据：将数据删除，可知id自增长序列，一直在增加delete from t1; 拓展学习 存储过程的游标cursor，遍历表中的每一行数据]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL_03]]></title>
    <url>%2F2019%2F05%2F19%2FMySQL-03%2F</url>
    <content type="text"><![CDATA[MYSQL多表查询 查询选课学生及其选修课程的情况（等值连接） 123456789101112131415161718192021# 查询出等值连接的所有列select *from student,scwhere student.sno=sc.sno# 查询出等值连接的指定列select sname,ssex,sdept,cno,grade from student,scwhere student.sno=sc.sno# 遇到重名的列时，一定要指定所属的表# 否则会报如下错误 # Column &apos;sno&apos; in field list is ambiguous，记住这个错误select sc.sno,sname,ssex,sdept,cno,grade from student,scwhere student.sno=sc.sno# 表的别名全权代表表,之后出现表的引用都要使用别名select sc.sno,s.sname,ssex,sdept,cno,grade from student AS s,scwhere s.sno=sc.sno 查询每一门课的间接先修课（即先修课的先修课） 1234567891011121314# 查询每一门课的间接先修课（即先修课的先修课）SELECT * from course c1, course c2where c1.cpno=c2.cnoSELECT c1.cno,c2.cpnofrom course c1, course c2where c1.cpno=c2.cno# 查出间接先修课一定存在的SELECT c1.cno,c2.cpnofrom course c1, course c2where c1.cpno=c2.cno and c2.cpno is not null 内连接inner join，等价于等值连接 查询选课学生及其选修课程的情况 12345678910select *from studentinner JOIN scon student.sno=sc.sno# 别名select s.sno &apos;学号&apos;,sname &apos;姓名&apos;from student sinner JOIN sc sson s.sno=ss.sno 外连接 保留舍弃的元组，在对应被连接表的分量部分用空值(NULL)代替,这种连接被叫做外连接 左外连接 查找每个学生的基本情况及选课情况 12345select *from student # table1 主表LEFT JOIN sc # table2 从表 on student.sno=sc.sno# 显示的结果是主表与从表进行等值连接的结果 + 主表与从表没有连接的记录 右外连接同理 复合条件连接 查询选修2号课程且成绩在90分以上的所有学生 123SELECT Student.Sno, Sname FROM Student, SC WHERE Student.Sno = SC.Sno AND SC.Cno= 2 AND SC.Grade &gt; 90； 查询选课学生的学号、姓名、选修的课程名及成绩 1234 SELECT Student.Sno，Sname，Cname，GradeFROM Student，SC，Course WHERE Student.Sno = SC.Sno and SC.Cno = Course.Cno； 嵌套查询 选修了课程号为2的学生的名字 12select sname from studentwhere sno in(select sno from sc where cno=2) 在SELECT … FROM … WHERE 语句结构的WHERE,FROM,SELECT子句中都可嵌入一个SELECT语句块 其上层查询称为外层查询或父查询 其下层查询称为内层查询或子查询 SQL语言允许使用多重嵌套查询 嵌套查询的实现一般是从里到外，即先进行子查询，再把其结果用于父查询作为条件 查询与“诸葛亮”在同一个系学习的学生。 1234① 确定“诸葛亮”所在系名 select sdept from student where sname=&apos;诸葛亮&apos; 1234② 查找所有在IS系学习的学生 SELECT * from studentwhere sdept= &apos;IS&apos;； 1234567将第一步查询嵌入到第二步查询的条件中SELECT * from studentwhere sdept=(select sdept from student where sname=&apos;诸葛亮&apos;) AND SNAME != &apos;诸葛亮&apos; 查询选修了课程名为“信息系统”的学生学号和姓名 1234567891011 SELECT Sno，Sname ③ 最后在Student关系中 FROM Student 取出Sno和SnameWHERE Sno IN (SELECT Sno ② 然后在SC关系中找出选 FROM SC 修了3号课程的学生学号 WHERE Cno IN (SELECT Cno ① 首先在Course关系中找出 FROM Course “信息系统”的课程号，为3号 WHERE Cname= ‘信息系统’ ) ); 找出每个学生超过他选修课程平均成绩的课程号。 1234567select sno,cnofrom sc xwhere grade&gt;( select avg(grade) from sc y where x.sno=y.sno) 查询其他系中比计算机科学某一学生年龄小的学生姓名和年龄 1234567SELECT * FROM STUDENT WHERE SAGE&lt; ANY(select sage from student where sdept=&apos;CS&apos;) AND SDEPT !=&apos;CS&apos;# 另一种写法SELECT * FROM STUDENT WHERE SAGE&lt; (select MAX(sage) from student where sdept=&apos;CS&apos;) AND SDEPT !=&apos;CS&apos; &lt;all 小于最小 小于所有（10,20,5） &gt;all 大于最大 &lt;any 小于最大 小与任何一个 &gt;any 大于最小 MYSQL常用函数数学函数 ABS(VAL)绝对值 MOD(V1,V2) 取余 FLOOR(X) 取下整 CEIL(X) 取上整 ROUND(X) 四舍五入 12345select ABS(-20);select MOD(9,4);select FLOOR(1.2);SELECT CEIL(1.2);SELECT ROUND(1.4); 字符串函数 CONCAT(str1,str2,…):返回来自于参数连结的字符串 LENGTH(str):返回字符串str的长度 LEFT(str,len):返回字符串str的最左面len个字符。 RIGHT(str,len):返回字符串str的最右面len个字符。 SUBSTRING(str,pos):从字符串str的起始位置pos返回一个子串 SUBSTRING(str,pos,len):从字符串str的起始位置pos返回一个len长度的子串 REVERSE(str):返回颠倒字符顺序的字符串str。 1234567SELECT CONCAT(&apos;HELLO&apos;,&apos;WORLD&apos;);SELECT LENGTH(&quot;HELLO&quot;);SELECT LEFT(&apos;HELLO&apos;,3); # 3代表长度，从左边开始取3个SELECT RIGHT(&apos;HELLO&apos;,3);SELECT SUBSTRING(&quot;HELLO WORLD&quot;,3); # 起始位置从1开始SELECT SUBSTRING(&quot;HELLO WORLD&quot;,3, 5); # LLO W 5代表长度，SELECT REVERSE(&quot;HELLO&quot;); # OLLEH 日期函数 123select CURTIME(); select CURDATE(); select NOW(); YEAR(date) HOUR(time) MINUTE(time) SECOND(time): DAYNAME(date):返回date的星期名字 DAYOFWEEK(date):返回日期date的星期索引(1=星期天，2=星期一, …7=星期六)。 1234567891011121314select NOW(); select CURTIME(); select CURDATE();select SYSDATE(); select YEAR(&apos;2012-09-09&apos;)select MONTH(&apos;2012-10-09&apos;)SELECT MINUTE(NOW())select MINUTE(&apos;2012-10-09 12:12:12&apos;)select dayname(&apos;2012-11-17 12:12:12&apos;)select DAYOFWEEK(&apos;2011-11-11 11:11:11&apos;)]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL_02]]></title>
    <url>%2F2019%2F05%2F19%2FMySQL-02%2F</url>
    <content type="text"><![CDATA[MYSQL[TOC] 一、数据库编程基础###1.1实体与属性 •实体 现实世界中任何一个可以识别的对象 数据库中的一条记录对应java中的一个对象，数据库中的一张表对应java中的一个类 •属性 实体所具有的特性，一个实体可用若干属性来描述 •关系数据库中的表现 实体的实例是储存在表中的行，属性是储存在表中的列。 1.2实体的关系•键（key） 在实体属性中，用于区别实体集合中不同个体的某个属性或某几个属性的组合，称为关键字（键）。 •主键 （Primary key 非空唯一） 一个实体的实例上可以有多个不同的键存在，所有这些符合条件的键称为候选键，被指定某个作为主键。 •外键（Foreign key） 非本实体实例的键，但它是其他实体实例的键。又称为外关键字或外部码。 1.3关系的三类完整性约束•实体完整性 ​ 每一表要求有一个主键(primary key)，不能取空值，也不能取相同的值 ​ •引用完整性 外键（foreign key）的取值要么空值，要么去参考的那个列的取值 •域完整性和域约束 限制某个列的取值 ​ check 约束 二、学生课程实例2.1要创建的表 学生表：Student(Sno,Sname,Ssex,Sage,Sdept) 1234567CREATE TABLE Student ( Sno VARCHAR(9) PRIMARY KEY, Sname VARCHAR(20) NOT NULL, Ssex VARCHAR(2), Sage INT, Sdept VARCHAR(20) ); 课程表：Course(Cno,Cname,Cpno,Ccredit)// cpno先修课 外键 12345678CREATE TABLE Course ( Cno INT PRIMARY KEY AUTO_INCREMENT, Cname VARCHAR(40) NOT NULL, Cpno INT , Ccredit INT, FOREIGN KEY (Cpno) REFERENCES Course(Cno) ); 学生选课表：SC(Sno,Cno,Grade)//sno cno 外键，也是联合主键 12345678CREATE TABLE SC (Sno VARCHAR(9), Cno INT, Grade INT, PRIMARY KEY (Sno,Cno), FOREIGN KEY (Sno) REFERENCES Student(Sno), FOREIGN KEY (Cno) REFERENCES Course(Cno) ); 2.2插入数据学生表 学 号 Sno 姓 名 Sname 性 别 Ssex 年 龄 Sage 所 在 系 Sdept 200215121 孙策 男 20 CS 200215122 妲己 女 19 CS 200215123 王昭君 女 18 MA 200515125 诸葛亮 男 19 IS 200215128 陈冬 男 18 IS 12345678INSERT INTO Student (Sno,Sname,Ssex,Sdept,Sage)VALUES (&apos;200215121&apos;,&apos;孙策&apos;,&apos;M&apos;,&apos;CS&apos;,20);# 一次插入多条数据insert into student(sno,sname,ssex,sage,sdept)values(&apos;200215122&apos;,&apos;妲己&apos;,&apos;F&apos;,19,&apos;CS&apos;),(&apos;200215123&apos;,&apos;王昭君&apos;,&apos;F&apos;,18,&apos;MA&apos;), (&apos;200215125&apos;,&apos;诸葛亮&apos;,&apos;M&apos;,19,&apos;IS&apos;),(&apos;200215128&apos;,&apos;张飞&apos;,&apos;M&apos;,18,&apos;IS&apos;) 课程表 课程号 Cno 课程名 Cname 先行课 Cpno 学分 Ccredit 1 数据库 5 4 2 数学 2 3 信息系统 1 4 4 操作系统 6 3 5 数据结构 7 4 6 数据处理 2 7 JAVA语言 6 4 12345678insert into course(cname,ccredit)values( &apos;数据库&apos;,4 ),( &apos;数学&apos;,2 ),( &apos;信息系统&apos;,4 ),( &apos;操作系统&apos;,3 ),( &apos;数据结构&apos;,4 ),( &apos;数据处理&apos;,2 ),( &apos;JAVA语言&apos;,4 ) constraint 约束 成绩表 学 号 Sno 课程号 Cno 成绩 Grade 200215121 1 92 200215121 2 85 200215121 3 88 200215122 2 90 200215122 3 80 123456insert into scvalues(&apos;200215121&apos;,1,92),(&apos;200215121&apos;,2,85),(&apos;200215121&apos;,3,88),(&apos;2002151student22&apos;,2,90),(&apos;200215122&apos;,3,80) 步骤 数据库sql文件导出 在对应的数据库上右击-》转储SQL文件-》结构与数据 导出到指定的位置 数据库sql文件导入 新建数据库-》右击-》运行SQL文件-》选择对应的sql文件-》开始 执行完成后F5刷新数据库，即可看到导入的表信息 2.3修改与删除 将学生200215121的年龄改为22岁 1update student set sage=22 where sno=&apos;200215121&apos; 所有成绩都减少3分 1update sc set grade=grade-3 删除学号为200215128的学生记录 1delete from student where sno=&apos;200215128&apos; 主外键建立后注意事项： 当主表没有对应的记录时，不能将记录添加到子表（包含外键的表） 成绩表中不能出现学员信息表中不存在的学号 不能更改主表中的值导致子表中的记录孤立 把学员信息表中的学号改变了，学员成绩表中的学号也应当随之改变 （级联更新） 子表存在与主表对应的记录，不能从主表中删除该行 不能把有成绩的学员删除了 删除主标签，先删子表 先删学员成绩表，后删除学员信息表 （级联删除） ###2.4查询 ####2.4.1运算符 算术运算符 + - * / %(取余) 123# mysql中字符串的连接select CONCAT(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;n&apos;)select CONCAT(&apos;1&apos;,&apos;1&apos;) % 5%3余数为2 ，取余就是结果就是2 赋值运算符 =（如在修改表记录时，set之后） 比较运算符 =(条件中) &gt; &lt; &lt;&gt;（不等于） &gt;= &lt;= !=（不等于） !&gt;(不大于) !&lt; 逻辑运算符 And与 java中使用&amp;&amp; 满足and两边的条件 Or 或 Java中使用|| 满足or一边的条件就行 Not 非 java中使用 ！ 非什么 其他运算符 数据范围 Between and Between 80 and 90-&gt;[80,90] Not between and 确定集合 In Not in (80,85,90)只在这3个数中选择 字符匹配（模糊查找） Like Not like _单个字符（汉字） %0个或多个字符或汉字 空值（NULL） Is Null 这里的null与空串的区别，请知晓 Is not null ####2.4.2查询语法（规定了书写的顺序） SELECT [ALL|DISTINCT] &lt;目标列表达式&gt; [，&lt;目标列表达式&gt;] … FROM &lt;表名或视图名&gt;[， &lt;表名或视图名&gt; ] … [ WHERE &lt;条件表达式&gt; ] [ GROUP BY &lt;列名1&gt; [ HAVING &lt;条件表达式&gt; ] ] [ ORDER BY &lt;列名2&gt; [ ASC|DESC ] ]； ####2.4.3查询练习 12# 查询所有学生, *代表所有列，列的顺序即为表中的顺序select * from student; 12# 查询学号与姓名、年龄信息(指定列)select sno,sname,sage from student; 12# 全体学生的姓名及其出生年份select sno,sname,sage,2018-sage from student; 12345# 为选定的列指定别名Alias,显示记录时将显示出来# 别名，用来显示的名字，小名select sno &apos;学号&apos;,sname &apos;姓名&apos;,sage &apos;年龄&apos;,2018-sage &apos;出生年份&apos; from student;# as 可加可不加select sno as &apos;学号&apos;,sname &apos;姓名&apos;,sage &apos;年龄&apos;,2018-sage &apos;出生年份&apos; from student; 12345# 查询全体学生的姓名、出生年份和所在系， --要求用小写字母表示所有系名select sname,2018-sage &apos;出生年份&apos;,sdept from student;# select LOWER(&apos;aBCd&apos;) 全部小写 select UPPER(&quot;AbcdE&quot;); 全部大写# LOWER讲所有的字母变成小写，应用该列的所有行select sname,2018-sage &apos;出生年份&apos;,LOWER(sdept) from student; 12345# 查询选修了课程的学号?有成绩就代表他选修了课程# 哪些学生选修了课程，列出他们# 去哪张表中查找数据select * from sc;select DISTINCT sno from sc; # distinct 去除重复内容 12-- 查询计算机科学系(CS)全体学生的名单SELECT * from student where Sdept=&apos;CS&apos; 12-- 查询所有年龄在20岁以下的学生姓名及其年龄SELECT * from student WHERE SAGE&lt;20 1234-- 查询年龄在20~23岁之间的学生的姓名、系别和年龄SELECT * FROM student WHERE SAGE BETWEEN 20 AND 23 # [20,23] -- 20-23之间的整数 20 21 22 23select * from student where sage in(20,21,22,23) 1234-- 查询信息系（IS）、数学系（MA）和计算机科学系（CS）学生的姓名和性别-- 条件都放在where的后面-- in后面跟有穷，有限的集合select sname,ssex from student where sdept in(&apos;IS&apos;,&apos;MA&apos;,&apos;CS&apos;); 12 12345-- like查找称为模糊查找-- 查询姓诸葛的学生信息 %有特殊含义，表示0到多个任意字符select * from student where sname like &apos;诸葛%&apos;-- 查询姓诸葛的学生信息，并且名字只有三个字的 _的特殊含义是1个任意字符select * from student where sname like &apos;诸葛_&apos; 112. -- 某些没有先修课的课程名 -- 条件判断是否为null，只能使用is null 或者is not null select cname from course where cpno is null1213. -- 查询计算机系年龄在20岁以下的学生姓名 -- java &amp;&amp; =》MYSQL中使用AND select sname from student WHERE Sdept=&apos;CS&apos; AND SAGE&lt;20 1214. # 查询全体学生情况，查询结果按所在系的系名称升序排列 -- ORDER BY sdept asc 字典顺序 默认是升序排列 select * from student ORDER BY sdept -- 降序排列 select * from student ORDER BY sdept desc 1215. -- 查询全体学生情况，查询结果按所在系的系名称升序排列,同一系中的学生按年龄降序排列 select * from student ORDER BY sdept ASC, SAGE DESC 1216. -- 查询一共有多少个学生 COUNT，统计查询出来的行数 SELECT COUNT(*) FROM STUDENT; SELECT count(SNO) FROM STUDENT; -- 了解 SELECT count(1) FROM STUDENT; 1217. -- 查询有先修课的课程一共有多少门 select count(*) from course; select count(cno) from course; -- count 统计不包括null值 select count(cpno) from course; 1218. -- 查询一共有多少人选修了课程 # select DISTINCT sno from sc 去重 # 先查询 再统计 select count(DISTINCT sno) as &apos;选课人数&apos; from sc; 1219. -- 聚集函数sum 求和 avg 求平均数 max 最大值 min最小值 -- 计算2号课程的学生平均成绩 select avg(grade) from sc where cno=2 1220. -- 显示2号课程的最高分 select max(grade) from sc where cno=2 -- 显示2号课程的最低分 select min(grade) from sc where cno=2 1221. -- 求2号课程所有成绩的总分 select sum(grade) from sc where cno=2 1222. -- 求各个课程号及其相应的选课人数 -- 先分组，在统计，统计的是组内的情况 -- GROUP BY之后的列才能出现在select语句的选择中，但是对于count统计没有这个限制 -- COUNT统计内部的列推荐为分组的列 select cno,count(cno) from sc GROUP BY cno 1234 ​ ![](C:/Users/NiGulas/Desktop/essay/img/mysql02_04.png)23. -- 按系查询男生和女生分别有多少人 select sdept, ssex, count(sno) from student GROUP BY sdept,ssex 1224. -- 查询选修了3门及以上课程的学生学号 (成绩表中有成绩，即表示选修了该课程) -- having是对分组后进一步进行筛选 -- group by之后进行进一步筛选必须使用having select sno from sc group by sno having count(sno)&gt;=3; 1225. -- 每个学生选修了多少门课程 select sno, count(sno) from sc group by sno; 1234 26. # 执行顺序是，先进行where筛选，再分组，再进行having筛选 select sno from sc where sno=&apos;200215122&apos; group by sno having count(sno)&gt;=3; 12345678910 ![](C:/Users/NiGulas/Desktop/essay/img/mysql02_05.png) HAVING短语与WHERE子句的区别： 1.WHERE从中选择满足条件的元组 2.HAVING短语作用于组，从中选择满足条件的组27. limit -- 分页 -- 每页显示三条记录 -- 第一页 n=1 SELECT * FROM student LIMIT 0,3; -- 第二页 n=2 SELECT * FROM student LIMIT 3,3; -- 第三页 n=3 SELECT * FROM student LIMIT 6,3; -- 第四页 n=4 SELECT * FROM student LIMIT 9,3; 起始位置 = (n-1) * 每页显示的数量; SELECT count(1) FROM student; 如果 总记录数 % 每页显示的数量 == 0 那么 总页数 = 总记录数 / 每页显示的数量 如果 总记录数 % 每页显示的数量 != 0 那么 总页数 = 总记录数 / 每页显示的数量 + 1 向上取整(12.1) = 13 向上取整(12.0) = 12 总页数 = ceil(总记录数 / 每页显示的数量); SELECT CEIL(count(1)/3) FROM student; ```]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL_01]]></title>
    <url>%2F2019%2F05%2F19%2FMySQL-01%2F</url>
    <content type="text"><![CDATA[MYSQL[TOC] 一、数据库概述1.1数据管理技术的发展阶段 人工阶段 50年代中期以前（磁带、纸带，无磁盘 ） 文件 50年代后期到60年代中期（磁盘 ） 数据库系统 60年代后期（大容量磁盘，硬件价格下降 ） 1.2数据库数据库(Database)是按照数据结构来组织、存储和管理数据的仓库。 数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各个用户共享。 数据库的作用？ 存储大量数据，方便查询与操作（select） 保持数据信息的一致,完整（主键 primary key 外键 foreign key 约束 check） 共享和安全（不同的用户赋予不同的权限，共享如第三方登录） 通过组合分析,产生新的有用信息（根据实际的业务信息查找数据显示） 如：数据库中的记录 1李明，男，21，1972，江苏，计算机系，1990 可翻译为： 1李明是个大学生，1972年出生，男,江苏人，1990年考入计算机系 1.3数据库管理系统 Database Management System简称DBMS 是一种操纵和管理数据库的软件，用于建立、使用和维护数据库 它对数据库进行统一的管理和控制，以保证数据库的安全性和完整性。 常见数据库： Oracle是目前世界上使用最为广泛的数据库管理系统, 是甲骨文公司的一款关系数据库管理系统 SqlServer是由Microsoft开发和推广的关系数据库管理系统 DB2 是美国IBM公司开发的一套关系型数据库管理系统, 主要应用于大型应用系统 MySql是一个小型的关系型数据库管理系统, 目前属于 Oracle 旗下产品. 与其他的大型数据库例如 Oracle、DB2、SQL Server等相比，MySQL 自有它的不足之处，但是这丝毫也没有减少它受欢迎的程度。对于一般的个人使用者和中小型企业来说，MySQL提供的功能已经绰绰有余，而且由于 MySQL是开放源码软件，因此可以大大降低总体拥有成本。 除了以上的关系数据库管理系统之外，还有Redis，MongoDB等非关系数据库，基于Key-Value存储的数据库，统称为NoSQL（Not only sql）。 关系数据库管理系统RDBMS(Relational Database Management System)：包括相互联系的数据集合 (数据库)和存取这些数据的一套程序 (数据库管理系统软件)。关系数据库管理系统就是管理关系数据库，并将数据组织为相关的行和列的系统。 二、Mysql安装安装教程 MySQL卸载​ 1.在控制面板\所有控制面板项\程序和功能中找到MySQL相关的应用程序,将应用程序卸载​ 2.把MySQL安装目录删除​ D:\MySQL​ 3.把MySQL的数据文件删除​ C:\ProgramData\MySQL​ 4.清除MySQL注册表​ 按win + R 输入 regedit 进入注册表​ 在注册表中找到 HKEY_LOCAL_MACHINE 项​ 右键点击 查找 勾选项 输入MySQL​ 删除以MySQL开头的文件夹 三、Navicat安装Navicat是一套快速、可靠并价格相当便宜的数据库管理工具，专为简化数据库的管理及降低系统管理成本而设。它的设计符合数据库管理员、开发人员及中小企业的需要。Navicat 是以直觉化的图形用户界面而建的，让你可以以安全并且简单的方式创建、组织、访问并共用信息。 安装时按照安装步骤安装即可，推荐不要安装在C盘 如果没有Navicat，我们访问数据库如下方式，如果想通过此方式测试，需要配置mysql环境变量，这里不在讲解，实现仅作为了解参考。 1234567891011121314151617181920212223242526272829303132333435363738C:\Users\ibf&gt;mysql -uroot -pmysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || beifeng || mysql || performance_schema || sakila || shclz |+--------------------+10 rows in set (0.55 sec)mysql&gt; use beifengDatabase changedmysql&gt; show tables;+------------------------+| Tables_in_beifeng |+------------------------+| messafe_info || role_anthority_info || role_info || staff_info || staff_salary |+------------------------+23 rows in set (0.06 sec)mysql&gt; select * from role_info -&gt; ;+---------+------------+------------------------+------------+| role_id | role_name | role_desc | role_state |+---------+------------+------------------------+------------+| 1 | 超级管理员 | 天天管学生 | 1 || 2 | 招生人员 | 找人培训 | 0 || 3 | 网大管 | 天天修电脑，天天接网线 | 1 |+---------+------------+------------------------+------------+3 rows in set (0.31 sec) 四、SQL概述Structured Query Language(结构化查询语言)的缩写。SQL是专为数据库而建立的操作命令集，是一种功能齐全的数据库语言。在使用它时，只需要发出“做什么”的命令，“怎么做”是不用使用者考虑的。SQL功能强大、简单易学、使用方便，已经成为了数据库操作的基础。 特点：一条SQL语句一个执行结果 重点 1select 选择，from 从...，insert插入 （into 到..），update 修改、更新，delete 删除，table 表，database 数据库，create创建，drop 丢弃， values 值（复数），primary key 主键，foreign key 外键，reference 引用，where 哪里，inner 内部的 join 连接 =》内连接，left join 左连接，right join 右连接，group（组，分组） by.. 根据..进行分组，having 有...，order by.. 根据..进行排序，desc（descending） 降序，asc（ascending）升序，auto_increment自增长，default 默认,null 空，not null非空，unique 唯一的，set 设置（值），distinct 确定的（去除重复数据），between ... and ... 在..和..之间，in 在..里面，like 像..一样(%,_)，limit 限制（分页时使用）(position,pageSize)，show 展示,use 使用,exists 存在,count统计，sum求和，avg平均值，max最大值，min最小值, describe描述 五、Mysql数据类型###5.1整形 MySQL数据类型 含义（有符号） tinyint 1个字节 范围(-128~127) smallint 2个字节 范围(-32768~32767) mediumint 3个字节 范围(-8388608~8388607) int 4个字节 范围(-2147483648~2147483647) bigint 8个字节 范围(+-9.22*10的18次方) 注意：应用int为主 5.2小数 MySQL数据类型 含义 float(m,d) 单精度浮点型 8位精度(4字节) m总个数，d小数位 double(m,d) 双精度浮点型 16位精度(8字节) m总个数，d小数位 decimal(m,d) 参数m&lt;65 是总个数，d&lt;30且 d&lt;m 是小数位 ( 将来可能会看到numberic，其余decimal类似 ) 设一个字段定义为float(6,3)，如果插入一个数123.45678,实际数据库里存的是123.457，但总个数还以实际为准，即6位。整数部分最大是3位，如果插入数12.123456，存储的是12.1234，如果插入12.12，存储的是12.1200 decimal(10,2) 123.45678=&gt; 123.45 12.123456=&gt;12.12 5.3字符串 MySQL数据类型 含义 char(n) 固定长度，最多255个字符 varchar(n) 固定长度，最多65535个字符 tinytext 可变长度，最多255个字符 text 可变长度，最多65535个字符 mediumtext 可变长度，最多2的24次方-1个字符 longtext 可变长度，最多2的32次方-1个字符 注意：应用以varchar为主 5.4日期 MySQL数据类型 含义 date 日期 ‘2008-12-2’ time 时间 ‘12:25:36’ datetime 日期时间 ‘2008-12-2 22:06:44’ timestamp 自动存储记录修改时间六留 六、数据库创建删除查看所有的数据库 1show databases; # sql语句 ；表示一条sql语句结束了 CREATE DATABASE [IF NOT EXISTS] 数据库名; 12create database myschool;create database if not exists myschool; DROP DATABASE [IF EXISTS] 数据库名; 12drop database abcd;drop database if exists abcd; 使用(切换)数据库 USE 数据库名; 1use beifeng； 查看某个库中的所有的表(注意:在操作表之前必须先使用数据库) 1show tables; 七、创建表CREATE TABLE 表名( 字段1 字段类型1, 字段2 字段类型2, …. 字段n 字段类型n ); 1234567CREATE TABLE Student ( Sno varchar(9) ， Sname varchar(20) ， Ssex varchar(2)， Sage INT， Sdept varchar(20) )； ##八、插入数据 INSERT INTO &lt;表名&gt; [(&lt;属性列1&gt;[，&lt;属性列2 &gt;…)] VALUES (&lt;常量1&gt; [，&lt;常量2&gt;] … ) 学 号 Sno 姓 名 Sname 性 别 Ssex 年 龄 Sage 所 在 系 Sdept 200215121 李勇 男 20 CS 200215122 刘晨 女 19 CS 200215123 王敏 女 18 MA 200515125 张立 男 19 IS 向表中指定列插入数据 123# 向表中的指定列插入数据 出现主键重复时，会报错，Duplicate 重复 Duplicate entry insert into student(sno,sname,sdept)values(&apos;08070203&apos;,&apos;诸葛亮&apos;,&apos;CS&apos;); 向表中所有列插入数据 写法1： 123# 按照列出现的顺序向表中插入数据时，(sno,sname,sage,ssex,sdept)可以省略不写，如上面的格式insert into student(sno,sname,sage,ssex,sdept)values(&apos;08070202&apos;,&apos;张飞&apos;,30,&apos;女&apos;,&quot;IS&quot;); 写法2： 123# 插入数据，按照列的顺序插入数据insert into studentvalues(&apos;08070202&apos;,&apos;张飞&apos;,30,&apos;女&apos;,&quot;IS&quot;); 九、创建表其他###9.1自增长 自动增长的，每添加一条数据，自动在上一个记录数上加1 123456# auto_increment 自增长 每次增加1create table role(id int PRIMARY key auto_increment,role_name varchar(20),note varchar(100)); 12345678# 自增长 不需要我们去手动维护他，就是插入数据的时候，不需要关注他是什么值# 自增长从1开始，只会增长，不会出现减少的情况INSERT into rolevalues(null, &apos;导演&apos;,&apos;导演都爱潜规则&apos;);INSERT into rolevalues(null, &apos;主演&apos;,&apos;主演都爱钱&apos;); 注意:自动增长的列必须是一个键(一般为主键) ###9.2空与空串 NULL 和 NOT NULL NULL:表示该列可以有空值数据 NOT NULL:表示该列不能有空值数据 空串 ‘’ 空串与空一样吗？ 不一样 ###9.3默认值 12345create table a6( a1 int, a2 int default 66, a3 varchar(32) default &apos;哈哈&apos;); ##十、更新数据 123456# update SET where # 更新条件，如更新自己的个人信息，根据什么条件可以确定是自己# 将ttt表中id列的值等于2的那个人的tnote列改为&apos;joy&apos;UPDATE ttt set tnote=&apos;joy&apos; where id=2 1234# 诸葛亮 年龄改为35岁，性别改为男，系改为ISUPDATE studentSET SAGE=35, SSEX=&apos;男&apos;,sdept=&apos;IS&apos;WHERE SNO=&apos;08070203&apos; 123# 将所有人的年龄全部增加2岁UPDATE studentSET sage=sage+2; 123# 没有加where条件，意味着修改表中的所有行，对于修改语句，写的时候要慎重update studentset ssex=&apos;M&apos; ##十一、删除 1234# drop database/table 数据库名/表名# 删除表中的数据，delete# 从ttt表中删除id为2的记录delete from ttt where id=2 123DELETE from student where sno=&apos;08070202&apos;# 不加任何条件，表示删除表中的所有数据delete from student; 作业 列名 数据类型 是否可为空 默认值 描述 ID INT 否 主键，自增长 SNO Varchar(10) 否 学号，唯一且非空 SNAME varchar(20) 否 姓名 SSEX varchar(1) 否 ‘男’ 性别 SBIRTHDAY DATE 是 出生日期 SAGE INT 是 年龄 创建如图所示的hero表 向表中插入如下的数据 ID Sno Sname Ssex Sage SBIRTHDAY 自增长的值 200215121 赵云 男 20 2000-09-15 自增长的值 200215122 不知火舞 女 19 1999-01-05 自增长的值 200215123 妲己 女 18 1990-08-07 所有人的年龄增加2岁 将赵云的姓名改成赵子龙 删除不知火舞]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NIO]]></title>
    <url>%2F2018%2F08%2F19%2FNIO%2F</url>
    <content type="text"><![CDATA[NIO概述使用IO流与存放在磁盘上的文件能够很方便的进行交互，但是它也存在一定的问题，问题的根源在于速度，由于磁盘IO速度远远小于CPU处理速度，这导致程序在进行IO操作的时候，不得不进行阻塞线程，等待IO操作完成，才能继续向下执行。 若某线程除了进行IO操作之外，还有其他重要的事情需要处理（给用户响应，并且不是IO的内容），但是现在遇到了IO，就必须停下来等IO，完了之后才进行下一步的操作，这有时候会使得用户觉得这个程序的处理速度太慢了，不能接受。 如上所述，Java IO可以说一种阻塞IO，这个时候就需要设计一种非阻塞IO，于是提出了Java NIO，可以称之为新IO，也可以称之为非阻塞IO。 Java NIO在进行read和write操作的时候，并不阻塞，会立即返回。 Java BIO，其全称是java blocking IO，相对的Java NIO 全称为java non-blocking IO。顾名思义，java nio 是一种非阻塞IO Java NIO中有三个非常重要的对象：Buffer、Channel和Selector 高并发场景，并且请求处理的数据量偏小 Netty Channelchannel是一个通道，它和Java IO中的流对象，用于连接文件实体。Java通过NIO来从文件中读写数据的时候，必须建立一个通道，通过这个通道将数据写入到文件中，或者从文件中读取数据。 Channel不能够直接被程序操作，channel中要么和文件打交道（网络上的资源也看做文件），要么和缓冲区打交道，除此之外，其他对象不能喝Channel交互。 通道可以是单向或者双向的。一个 channel 类可能实现定义read( )方法的 ReadableByteChannel 接口,而另一个 channel 类也许实现 WritableByteChannel 接口以提供 write( )方法。实现这两种接口其中之一的类都是单向的,只能在一个方向上传输数据。如果一个类同时实现这两个接口,那么它是双向的,可以双向传输数据。 1234FileChannel // 可以从文件中读写数据DatagramChannel //可以从UDP连接中读写数据SocketChannel //可以从TCP连接中读写数据ServerSocketChannel //用于监听TCP连接，一旦有连接来了之后，接受连接，并创建一个SocketChannel Buffer缓冲区是程序和通道之间的桥梁，程序有数据要写入文件的时候，会首先将数据写入到缓冲区中，之后在由缓冲区与Channel交互，将这些数据写入到文件中，反过来就是将Channel从文件中读取的数据先放到缓冲区中，之后程序从缓冲区中拿数据。 Buffer是一个对象，它用来存放即将发送的数据和即将到来的数据。Buffer是NIO核心思想，它与普通流IO的区别是，普通流IO直接把数据写入或读取到Stream对象中，而NIO是先把读写数据交给Buffer，后在用流处理的。Buffer实际上就是一个数组，通常是字节数组，这个数组提供了访问数据的读写等操作属性，如位置，容量，上限等概念。 缓冲区类型,基本上就是按照Java类型来分的 12345678ByteBufferMappedByteBufferCharBufferDoubleBufferFloatBufferIntBufferLongBufferShortBuffer 获取缓冲区对象的方法 12//获取以字节缓冲区对象ByteBuffer byteBuffer = ByteBuffer.allocate(48); capacitycapacity表示的是一块缓冲区的总容量，它一旦被设定好之后就不在变化。 position表示当前指针位置，缓冲区目前所处的状态不同，它所表示的含义也不同，当在往缓冲区中写入数据的时候，position只想最后写入的位置；当从缓冲区中读取数据的时候，position表示目前已经读到哪个位置了。 limit冲区目前所处的状态不同，它所表示的含义也不同，当在往缓冲区中写入数据的时候，limit表示缓冲区还有多少未用空间；当从缓冲区中读取数据的时候，limit表示的是在读数据之前，最后写入数据的位置。 mark()/reset() mark在对缓冲区进行操作过程中，对缓冲区打个标记点，在继续对缓冲区操作一会，调用reset()方法，就会使得position指向到刚刚打标记点的那个位置。 缓冲区有两种状态，写状态和读状态，当之前一直在往缓冲区中写入数据，此时想从缓冲区中读取数据，此时不能够直接调用get()方法，必须首先调用flip（）进行缓冲区翻转，之后才能够读取。 1234//首先翻转buffer.flip();//读取数据buffer.get() 原因：从缓冲区中读取数据是根据position来读取的。当一直写数据的时候，position会不断变化，一直指向当前正在操作的位置，此时想从缓冲区中读取数据的话，不翻转直接读，那么读取position的下一位，要么是脏数据要么就没有数据，为了避免这种情况，NIO设计师们设计不翻转直接读的时候会报错。 调用flip()之后,limit的值将会置为position，position将会置为0。然后在将缓冲区清空或者清空已经读取的数据位置，为下一次往缓冲区中写入数据腾出位置。 因此操作缓冲区的步骤：1.往缓冲区中写数据2.buffer.flip()3.从缓冲区中读取数据2.清空缓冲区（clear()/compact()） SelectorSelector会不断轮询注册在Selector上的通道(Channel)，如果这个通道发生了读写操作，这个通道就会处于就绪状态，会被Selector察觉到，然后通过SelectionKey可以取出就绪的Channel集合，从而进行IO操作。 Selector可以用于管理Channel，此时Channel需要向Selector进行注册，只有注册之后，Selector才会真正的去管理Channel。一个Selector可以管理多个通道，Selector通过select()方法不断的轮休这些Channel，当所有的Channel上都没有IO操作的时候，select()会阻塞，当注册在Selector上的Channel至少有一个需要进行IO操作的时候，正在执行select()方法的线程将会被唤醒，并且返回一个整数，代表有几个Channel需要进行IO操作。 每当有用户连接时，就会创建一个SocketChannel，并将其注册到Selector上。服务器只需要开启一个线程就可以处理多个用户连接：这条线程执行Selector，如果没有连接，阻塞，有连接的话，建立通道并注册到Selector上，交由Selector管理，Selector不管轮询注册在其上的Channel，有IO操作的话，就进行处理，当数据没有完全到来的时候也可以处理，此时read操作非阻塞不需要等待，立即返回，这样就可以使得一条线程处理多个用户，大大提高了线程的数据处理能力，也减轻了服务器端的压力。（netty框架据说可以一条线程处理成千上万个用户连接） 1234SelectionKey.OP_CONNECT //关注连接SelectionKey.OP_ACCEPT SelectionKey.OP_READ //关注读IOSelectionKey.OP_WRITE //关注写IO]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区别($与#)]]></title>
    <url>%2F2018%2F06%2F22%2F%E5%8C%BA%E5%88%AB-%E4%B8%8E%2F</url>
    <content type="text"><![CDATA[${ } 和 #{ }的区别动态 SQL 是 mybatis 的强大特性之一，也是它优于其他 ORM 框架的一个重要原因。mybatis 在对 sql 语句进行预编译之前，会对 sql 进行动态解析，解析为一个 BoundSql 对象，也是在此处对动态 SQL 进行处理的。在动态 SQL 解析阶段， #{ } 和 ${ } 会有不同的表现。 ${} 在动态解析的时候，会将我们传入的参数当做String字符串填充到我们的语句中 123&lt;update id=&quot;updateRole&quot; parameterType=&quot;role&quot;&gt; update t_role set role_name=$&#123;roleName&#125;,note=$&#123;note&#125; where id=$&#123;id&#125;&lt;/update&gt; 生成的sql语句1update t_role set role_name=abc,note=描述 where id=4 报错1Unknown column &apos;abc&apos; in &apos;field list&apos; #{} 在动态解析的时候， 会解析成一个参数标记符 12Preparing: update t_role set role_name=?,note=? where id=? Parameters: abc(String), 描述(String), 4(Integer) 预编译之前的 SQL 语句已经不包含变量了，完全已经是常量数据了。相当于我们普通没有变量的sql。 综上所得， ${ } 变量的替换阶段是在动态 SQL 解析阶段，而 #{ }变量的替换是在 DBMS 中。 这是 #{} 和 ${} 我们能看到的主要的区别，除此之外，还有以下区别： #方式能够很大程度防止sql注入。 $方式无法防止Sql注入。 $方式一般用于传入数据库对象，例如传入表名，列明. 一般能用#的就别用$.]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet_01]]></title>
    <url>%2F2018%2F06%2F20%2FServlet_01%2F</url>
    <content type="text"><![CDATA[SERVLET[TOC] ##引入 WEB，在英语中web即表示网页的意思，它用于表示Internet主机上供外界访问的资源。 Internet上供外界访问的Web资源分为： 静态web资源（如html 页面）：指web页面中供人们浏览的数据始终是不变。 动态web资源：指web页面中供人们浏览的数据是由程序产生的，不同时间点访问web页面看到的内容各不相同。 常用动态web资源开发技术： JSP/Servlet、ASP、PHP等 在Java中，动态web资源开发技术统称为JavaWeb，我们课程的重点也是教大家如何使用Java技术开发动态的web资源，即动态web页面。 在互联网上如何实现资源访问？ 计算机通过统一资源定位符实现资源访问 URL：Uniform Resource Locator的缩写 唯一能识别Internet上具体的计算机、目录或文件夹位置的命名约定 程序架构B/S与C/S B/S架构工作原理 请求与响应模式进行交互 ​ 服务处理请求与向发送请求方响应 Web服务器学习web开发，需要先安装一台web服务器，然后再在web服务器中开发相应的web资源（jsp，html，css，js），供用户使用浏览器访问。 服务器可以向发出请求的浏览器提供文档（响应数据）的程序，提供网上的信息浏览服务。 常用的Web服务器 Microsoft：IIS Apache：Tomcat Oracle：WebLogic IBM：WebSphere Nginx Tomcat服务器 Apache Jakarta的开源项目 轻量级应用服务器 开源、稳定、资源占用小 Tomcat官网 tar.gz文件是Linux操作系统下的安装版本 exe文件是Windows系统下的安装版本(上线) zip文件是Windows系统下的压缩版本(开发)绿色 Tomcat目录结构 配置与启动Tomcat 默认端口号：8080 通过配置文件server.xml修改Tomcat端口号 启动Tomcat bin\startup.bat 访问http://localhost:8080查看Tomcat主页 停止Tomcat bin\shutdown.bat Eclipse中配置Tomcat Window -》 preferences -》Server-》Runtime Environments -》Add 选择tomcat的（解压）安装目录 Window -》show view -》other -》搜索server，点击搜索到的server-》open 点解server面板的链接-》选择添加的tomcat-》next-》finish 完成Tomcat与Eclipse的集成 初识Servlet创建Web项目 File - &gt; new -&gt; other -&gt;搜索dynamic-》Dynamic Web Project-》next-》填写项目名-》next-》next-》勾上Generate web.xml……-&gt;finish 在WebContent目录下创建index.html，在HTML中随便写些东西，保存 Servelt Servlet 是一个 Java程序，是在服务器上运行以处理客户端请求并做出响应的程序 Servlet运行原理 目录结构 第一个Servlet web.xml配置 12345678910&lt;!-- 注册servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!-- 名字任意 --&gt; &lt;servlet-class&gt;com.dsj.controller.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- mapping映射，url到servlet的映射 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!-- 此处的name必须要与上面的一致 --&gt; &lt;url-pattern&gt;/hello.abc&lt;/url-pattern&gt; &lt;!-- pattern 匹配，url匹配 --&gt; &lt;/servlet-mapping&gt; 问题 单词拼错 123456789101112131415163. 自动构建，可以将变化的代码自动生成到新的class文件中，之后加载运行便可以看到改动的变化，如果还不行，在尝试使用clean，建议只清理（clean）自己当前正在用的的工程4. HTML,CSS,JS对这些文件的修改不需要重启工程，只要在修改之后，刷新页面即可显示修改后的变化，对于将来要讲的jsp与java代码类似，要等jsp文件构建以下，才能重新执行，也不需要重启工程，对**web.xml**配置文件的改变，需要重启工程。5. WEB-INF目录是不可以被外界通过url地址直接访问的，所以目前创建html文件不要创建到WEB-INF目录下，创建在Web-Content目录下6. JDK不要用10.x一系列版本，使用1.8.x就行，不用卸载，只需要再装一个1.8.x版本，只要改JAVA_HOME环境变量即可7. 项目运行，在指定的资源（html，jsp，servlet）上，右击run on server执行，启动之后，会在eclipse地址栏直接访问到被右击的资源。 **流程**请求地址：```http://localhost:8080/HelloWeb/hello.abc localhost:8080-》Tomcat HelloWeb-》到对应的项目名称为HelloWeb的项目 hello.abc-》一开始在项目发布的时候会加载web.xml配置文件 12map1: HelloServlet com.dsj.controller.HelloServletmap2: hello.abc HelloServlet 当请求来的时候，就可以根据hello.abc到map2中去找匹配的key值，123456789101112**怎样查看Servlet源码**点击对应的类，看不到其中的源码，点击```Attach Source```,选择External Location-》External File-》选择这个srcservlet.zip-》打开就行了**反射**（了解）通过累的全限定名（```com.dsj.controller.HelloServlet```），可以创建对象，可以设置对象的属性值，可以调用其方法，不管是私有的还是公有的。 public class Student { private String name; public String address; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public String sleep() { return “又睡觉了”; } @Override public String toString() { return “Student [name=” + name + “, address=” + address + “]”; }} 12反射main public static void main(String[] args) { String clzName = &quot;com.dsj.Student&quot;; try { // 类的类 Class clz = Class.forName(clzName); // 使用无参数的构造器创建实例 Object obj = clz.newInstance(); //new创建 Instance 实例，对象// Student stu = (Student) clz.newInstance();// stu.setName(“lisi”); Field[] field = clz.getDeclaredFields(); for(Field f:field) { if(f.getName().equals(&quot;name&quot;)) { f.setAccessible(true); f.set(obj, &quot;张三&quot;); } if(f.getName().equals(&quot;address&quot;)) { f.set(obj, &quot;苏州市&quot;); } } System.out.println(obj.toString()); Method[] ms = clz.getDeclaredMethods(); for(Method m:ms) { if(m.getName().equals(&quot;sleep&quot;)) { // args 方法需要传递哪些参数 Object... 可变长度的参数（0-n个参数） // oo接受方法调用的返回值 Object oo = m.invoke(obj);// 调用sleep方法 System.out.println(oo); } } } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (InstantiationException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (IllegalAccessException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (IllegalArgumentException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (InvocationTargetException e) { // TODO Auto-generated catch block e.printStackTrace(); } }1234**可变长度的参数** public static void main(String[] args) {// flex1(); System.out.println(“==========”); flex1(“a”); System.out.println(“==========”); flex1(“b”,”c”); System.out.println(“==========”); flex1(“d”,”e”,”f”); } // 可变长度的参数必须放在最后一个位置 public static void flex1(String dd, String… strs) { System.out.println(strs.length); for(String s:strs) { System.out.println(s); } } **404:**请求的网页不存在，检查缩写url地址是否有问题 **500:**服务器内部错误，检查服务器代码问题]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java-Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射]]></title>
    <url>%2F2018%2F06%2F15%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[反射Java程序对象类型: 编译时类型 运行时类型 1Person p=new Student(); p译时是Person类型，而运行时是Student类型 如何解决这个编译时与运行时的类型不同呢? 假设在编译时和运行时都完全知道类型的具体信息，这种情况下用instanceof判断，再进行强制转换实现 第二种做法:编译时根本无法预知该对象和类可能属于哪些类，程序只能依靠运行时信息来发现该对象和类的真实信息，这就必须使用反射 获得Class对象 我们知道类加载后，系统会生成此类的java.lang.Class对象，通过该Class对象就可访问JVM中的这个类。Java程序中获得Class对象通常用如下3种方式: 使用Class类的forName(String className)静态方法。className包含完整包名与类名 调用某个类的class属性来获取该类对应的Class对象，如 Person.class将会返回Person类对应的Class对象 调用某个对象的getClass()方法。这个方法是Object类中的一个方法,它会返回该对象所属类对应的Class对象 在获得了某个类所对应的Class对象后，程序就可以调用Class对象的方法来获得该对象和该类的真实信息了。 获取Class对象对应类的所包含的构造器 获取Class对象对应类所包含的方法 获取Class对应类所包含的Field 获取Class对象对应类的相关类、接口等 获取Class对象对应类的修饰符、所在包、类名等基本信息 判断该类是否为接口、枚举类型等 使用反射生成并操作对象 通过反射来生成对象有如下两种方式 1.使用Class对象的newInstance()方法来创建该Class对象对应类的实例，这种方式要求该Class对象的对应类有默认构造器，执行newInstance()方法时实际上就是利用默认构造器创建该类的实例 2.先使用Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建该Class对象对应的实例。通过这种方式可以选择使用指定的构造器来创建实例 前一种方法较常见，很多JavaEE框架中都需要根据配置文件信息来创建Java对象，从配置文件中读取的只是某个类的字符串类名，程序需要根据该字符串来创建对应的实例，就必须使用反射 调用方法 获得某个类对应的Class对象后，就可以通过该Class对象的getMethods()方法或getMethod()方法来获取全部方法或指定方法，前一个方法是返回一个Method数组，后者是Method对象 Method对象对应一个方法，获得Method对象后，程序就可以通过该Method来调用它对应的方法。在Method里包含一个invoke()方法，方法的签名如下: Object invoke(Object obj,Object…args):obj是执行该方法的主调，后面的args是参数。 操作数组 java.lang.reflect包下提供了一个Array类，Array对象可以代表所有的数组，程序可以通过使用Array来动态地创建数组，操作数组元素等 Array提供了如下几个方法: static Object newInstance(Class&lt;?&gt;componentType,int… length):创建一个具有指定元素类型、指定维度的新数组 static xxx getXxx(Object **array,int index):返回array数组中第index元素，如果数组元素是引用类型，则该方法变为**get(Object array,int index); static void setXxx(Object array,int index,xxx val):将array数组中第index元素值设定为val 如果数组元素是引用类型，则该方法变为set(Object array,int index,Object);]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池]]></title>
    <url>%2F2018%2F06%2F07%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[线程池线程池就是首先创建一些线程，它们的集合称为线程池。使用线程池可以很好地提高性能，线程池在系统启动时即创建一些空闲的线程，程序将一个任务传给线程池，线程池就会启动一条线程来执行这个任务，执行结束以后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个任务（提高线程复用，减少性能开销）。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络sockets等的数量。例如，线程数一般取cpu数量+2比较合适，线程数过多会导致额外的线程切换开销。 工作机制 在线程池的编程模式下，任务是提交给整个线程池，而不是直接提交给某个线程，线程池在拿到任务后，就在内部寻找是否有空闲的线程，如果有，则将任务交给某个空闲的线程。一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。 使用线程池的原因 多线程运行时间，系统不断的启动和关闭新线程，成本非常高，会过渡消耗系统资源，以及过渡切换线程的危险，从而可能导致系统资源的崩溃。这时，线程池就是最好的选择了。 当线程到达一定数量，程序反而因线程在cpu切换开销的原因处理效率降低。无论的你的服务器cpu是多少核心，这个现象都有发生的可能。 线程池1234Executors.newCachedThreadPool()：无限线程池Executors.newFixedThreadPool(nThreads)：创建固定大小的线程池Executors.newScheduledThreadPool(...)：定长周期性执行线程池Executors.newSingleThreadExecutor()：创建单个线程的线程池自定义线程池 newCachedThreadPool可缓存线程池，先查看池中有没有以前建立的线程，如果有，就直接使用。如果没有，就建一个新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务.线程池为无限大，当执行当前任务时上一个任务已经完成，会复用执行上一个任务的线程，而不用每次新建线程 1234567891011121314151617181920public static void main(String[] args) &#123; // 创建一个可缓存线程池 // ExecutorService是Java提供的用于管理线程池的类。该类的两个作用：控制线程数量和重用线程 ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; try &#123; //sleep可明显看到使用的是线程池里面以前的线程，没有创建新的线程 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; cachedThreadPool.execute(new Runnable() &#123; public void run() &#123; //打印正在执行的缓存线程信息 System.out.println(Thread.currentThread().getName() + &quot;正在被执行&quot;); &#125; &#125;); &#125; &#125; 输出 12345pool-1-thread-1正在被执行pool-1-thread-1正在被执行pool-1-thread-1正在被执行pool-1-thread-1正在被执行.... newFixedThreadPool创建一个可重用固定个数的线程池，以共享的无界队列方式来运行这些线程。 1234567891011121314151617public static void main(String[] args) &#123; //创建一个可重用固定个数的线程池 ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3); for (int i = 0; i &lt; 10; i++) &#123; fixedThreadPool.execute(new Runnable() &#123; public void run() &#123; try &#123; //打印正在执行的缓存线程信息 System.out.println(Thread.currentThread().getName() + &quot;正在被执行&quot;); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; &#125; 输出-顺序不一定一致 1234567pool-1-thread-3正在被执行pool-1-thread-1正在被执行pool-1-thread-2正在被执行pool-1-thread-1正在被执行pool-1-thread-3正在被执行pool-1-thread-2正在被执行.... newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行 12345678910111213141516public static void main(String[] args) &#123; //创建一个定长线程池，支持定时及周期性任务执行——定期执行 ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); //延迟1秒后每3秒执行一次 /** * command – the task to execute * initialDelay – the time to delay first execution * period – the period between successive executions * unit – the time unit of the initialDelay and period parameters */ scheduledThreadPool.scheduleAtFixedRate(new Runnable() &#123; public void run() &#123; System.out.println(&quot;延迟1秒后每3秒执行一次&quot;); &#125; &#125;, 1, 3, TimeUnit.SECONDS); &#125; 输出 123延迟1秒后每3秒执行一次延迟1秒后每3秒执行一次... newSingleThreadExecutor()创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。 1234567891011121314151617public static void main(String[] args) &#123; //创建一个单线程化的线程池 ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; singleThreadExecutor.execute(new Runnable() &#123; public void run() &#123; try &#123; //结果依次输出，相当于顺序执行各个任务 System.out.println(Thread.currentThread().getName() + &quot;正在被执行,打印的值是:&quot; + index); Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; &#125; 输出 12345pool-1-thread-1正在被执行,打印的值是:0pool-1-thread-1正在被执行,打印的值是:1pool-1-thread-1正在被执行,打印的值是:2pool-1-thread-1正在被执行,打印的值是:3..顺序执行 线程池的创建12345678910111213141516171819202122232425262728293031323334/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the * pool * @param keepAliveTime when the number of threads is greater than * the core, this is the maximum time that excess idle threads * will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are * executed. This queue will hold only the &#123;@code Runnable&#125; * tasks submitted by the &#123;@code execute&#125; method. * @param threadFactory the factory to use when the executor * creates a new thread * @param handler the handler to use when execution is blocked * because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if one of the following holds:&lt;br&gt; * &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt; * &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt; corePoolSize&#125; * @throws NullPointerException if &#123;@code workQueue&#125; * or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null */ public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 1234567corePoolSize :线程池的核心池大小，在创建线程池之后，线程池默认没有任何线程。当有任务过来的时候才会去创建创建线程执行任务。换个说法，线程池创建之后，线程池中的线程数为0，当任务过来就会创建一个线程去执行，直到线程数达到corePoolSize 之后，就会被到达的任务放在队列中。（注意是到达的任务）。换句更精炼的话：corePoolSize 表示允许线程池中允许同时运行的最大线程数。如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。maximumPoolSize :线程池允许的最大线程数，他表示最大能创建多少个线程。maximumPoolSize肯定是大于等于corePoolSize。keepAliveTime :表示线程没有任务时最多保持多久然后停止。默认情况下，只有线程池中线程数大于corePoolSize 时，keepAliveTime 才会起作用。换句话说，当线程池中的线程数大于corePoolSize，并且一个线程空闲时间达到了keepAliveTime，那么就是shutdown。Unit:keepAliveTime 的单位。workQueue ：一个阻塞队列，用来存储等待执行的任务，当线程池中的线程数超过它的corePoolSize的时候，线程会进入阻塞队列进行阻塞等待。通过workQueue，线程池实现了阻塞功能threadFactory ：线程工厂，用来创建线程。handler :表示当拒绝处理任务时的策略。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理]]></title>
    <url>%2F2018%2F06%2F03%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[动态代理概述动态代理的意义在于生成一个占位（又称代理对象），来代理真实对象，从而控制真实对象的访问。 场景：假如你是一家软件公司的软件工程师，客户带着需求去找公司显然不会直接和你谈，而是去找商务谈，此时客户会认为商务代表公司。 客户通过商务去访问软件工程师，那么商务对象的意义在什么地方呢？ 客户可以进行谈判，如项目启动前的商务谈判，软件的价格，交付，进度的时间节点等，或者项目完成后的商务追讨，应收账款等。商务也有可能在开发之前谈判失败，此时商务就会根据公司规则去结束和客户之间的合作关系，这些都不用软件工程师来处理。 因此，代理的作用就是，在真实对象访问之前或者之后加入对应的逻辑，或者根据其他规则控制是否使用真实对象，正如上例中商务控制了客户对软件工程师的访问。 经过上面的论述，我们知道商务和软件工程师是代理和被代理的关系，客户是经过商务去访问软件工程师的。此时客户就是程序中的调用者，商务就是代理对象，软件工程师就是真实对象。 我们需要调用者调用真实对象之前产生一个代理对象，而这个代理对象需要和真实对象建立代理关系，所以代理必须分为两个步骤 代理对象和真实对象建立代理关系 实现代理对象的代理逻辑方法 Java中有多种动态代理技术，如JDK，CGLIB，Javassist，ASM。常用的有两种，一是JDK动态代理，JDK自带的功能，二是CGLIB，第三方提供的技术（需要jar包）。Spring常用JDK和CGLIB，而mybatis还是用了Javassist，无论哪种代理技术，理念都是相似的。 JDK 动态代理Java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类与接口，可以生成JDK动态代理类或动态代理对象 实现步骤 1.先建立真实对象(被代理对象)，然后实现代理逻辑。 12345678910public interface IHelloWorld &#123; public void sayHello();&#125;public class HelloWorldImpl implements IHelloWorld&#123; @Override public void sayHello() &#123; System.out.println(HelloWorldImpl.class.getSimpleName() + &quot;: sayHello&quot;);&#125;&#125; 2.JDK动态代理中要实现代理逻辑类，必须实现接口java.lang.reflect.InvocationHandler，其中定义了一个invoke方法，用于代理方法逻辑的实现。 12345678910111213141516171819202122232425262728293031import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class JdkProxyExample implements InvocationHandler &#123;/** * 真实对象 */private Object target;// 软件工程师对象/** * 建立真实对象和代理对象的关系 * 建立商务和软件工程师的关系 * @param target * @return 代理对象 -》商务对象 */public Object bind(Object target) &#123; this.target = target; // target.getClass().getInterfaces()表示生成的代理对象下挂在那些接口下 return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);&#125;// proxy 就是bind方法生成的对象@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;前&quot;); Object obj = method.invoke(target, args);// 真实对象方法调用，商务逻辑控制软件工程师的访问 System.out.println(&quot;后&quot;); return obj;&#125;&#125; 3.主类运行 12345678910public static void main(String[] args) &#123; JdkProxyExample jpe = new JdkProxyExample(); // 被代理对象-真实对象 程序员 HelloWorldImpl hwi = new HelloWorldImpl(); // 绑定关系，存在下挂接口IHelloWorld // 代理对象- 商务对象 IHelloWorld proxy = (IHelloWorld) jpe.bind(hwi); // 通过代理对象调用，进入代理逻辑方法invoke中 proxy.sayHello();&#125; 动态代理设计由于动态代理一般都比较难理解，程序设计者会设计一个拦截器接口供开发者使用，开发者只需要知道拦截器接口的方法、含义和作用即可，无需知道动态代理是怎么实现。 JDK动态代理来实现一个拦截器的步骤如下： 1、定义拦截器接口 1234Before 在方法被调用之前调用通知After 在方法完成之后调用通知，无论方法执行是否成功After-returning 在方法成功执行之后调用通知After-throwing 在方法抛出异常后调用通知 2.定义接口 1234567891011public interface IInterceptor &#123;/** * @param proxy 代理对象 * @param target 真实对象 * @param method 方法 * @param args 运行方法参数*/ public boolean before(Object proxy, Object target, Method method,Object[] args); public void around(Object proxy, Object target, Method method,Object[] args); public void after(Object proxy, Object target, Method method,Object[] args);&#125; 3.定义接口实现类 123456789101112131415public class MyInterceptor implements IInterceptor&#123;@Overridepublic boolean before(Object proxy, Object target, Method method, Object[] args) &#123; System.out.println(&quot;反射方法前逻辑&quot;); return false;&#125;@Overridepublic void around(Object proxy, Object target, Method method, Object[] args) &#123; System.out.println(&quot;取代了被代理对象的方法&quot;);&#125;@Overridepublic void after(Object proxy, Object target, Method method, Object[] args) &#123; System.out.println(&quot;反射方法后逻辑&quot;);&#125;&#125; 4.建立JDK动态代理类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class JdkProxyInterceptor implements InvocationHandler &#123; // 真实对象 private Object target; // 拦截器全限定名 private String interceptorClass = null;public JdkProxyInterceptor(Object target, String interceptorClass) &#123; this.target = target; this.interceptorClass = interceptorClass;&#125;/** * 绑定委托对象并返回一个（代理占位） * @param target 真实对象 * @param interceptorClass 代理对象（占位） * @return */public static Object bind(Object target, String interceptorClass)&#123;// 取得代理对象 return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);&#125;// new JdkProxyInterceptor(target, interceptorClass)/** * */@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (null == interceptorClass) &#123; // 没有设置拦截器则直接反射原有方法 return method.invoke(target, args); &#125; Object result = null; // 通过反射生成拦截器 IInterceptor interceptor = (IInterceptor) Class.forName(interceptorClass).newInstance(); // 调用前置方法 if(interceptor.before(proxy, args, method, args)) &#123; // 反射原有对象方法 result = method.invoke(target, args); &#125; else &#123;// 返回false执行around方法 interceptor.around(proxy, args, method, args); &#125; // 调用后置方法 interceptor.after(proxy, args, method, args); return result; &#125;&#125; 5.main法调用 12 综上可知： 开发者只要知道拦截器的作用就可以编写拦截器了，编写完后可以设置拦截器，这样就完成了任务，所以对于开发者而言相对简单了 设计者可能是精通Java的开发人员，他来完成动态代理的逻辑 设计者只会把拦截器接口暴露给开发者使用，让动态代理的逻辑在开发者的视野中“消失”]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Junit]]></title>
    <url>%2F2018%2F05%2F23%2FJunit%2F</url>
    <content type="text"><![CDATA[单元测试单元测试是编写测试代码，应该准确、快速地保证程序基本模块的正确性。强调建立测试数据的一段代码，可以先测试，然后再应用。这个方法就好比“测试一点，编码一点，测试一点，编码一点……”，增加了程序员的产量和程序的稳定性，可以减少程序员的压力和花费在排错上的时间。 在IDEA中安装单元测试插件： 1File-&gt;Settings-&gt;Plugins(左侧菜单)-&gt;JUnitGenerator 2.0(输入框中)-&gt;Restart 配置插件 Settings-&gt;Other Settings-&gt;JUnit Generator(点击左侧)–&gt;Properties–&gt;修改Output Path为${SOURCEPATH}/test/java/${PACKAGE}/${FILENAME} –&gt;修改Default Template为JUnit4 –&gt;点击JUnit4页签 –&gt;将package test.$entry.packageName;修改成package $entry.packageName; –&gt;点击OK[确定]保存并退出设置 创建并配置测试目录 创建一个和src同级别的文件夹叫test(逻辑代码放src里，测试代码放test里，项目-右击-New-&gt;Directory-&gt;test)。接着在IntelliJ IDEA里还要把这个test文件夹要设置成测试文件的根目录，test上右击Mark Directory As - Test Sources Root。 创建测试类 进入需要进行单元测试的类，通过Cmd + Shift + T创建测试类，勾选需要测试的方法，点击确认。Create New Test 1234567891011public class MathTest &#123; public int testAdd(int x, int y)&#123; System.out.println(x + y); return x + y; &#125; public int testSub(int x, int y)&#123; System.out.println(x - y); return x - y; &#125;&#125; 若显示如上library not found的问题，请参照如下问题解决 问题 java: 程序包org.junit不存在 File -&gt; Project Struct… -&gt; Libraies -&gt; 点击绿色的加号 -&gt; Java -&gt; 找到 IDEA 安装路径下的 Lib 中的junit-4.12 -&gt; 确定完就行了 如上一次添加如下类库： 1234567891011121314151617public class MathTestTest &#123; @Before public void setUp() throws Exception &#123; System.out.println(11); &#125; @After public void tearDown() throws Exception &#123; &#125; @Test public void testAdd() &#123; assertEquals(30,new MathTest().testAdd(10,20)); &#125; @Test public void testSub() &#123; new MathTest().testSub(10,20); &#125;&#125; 语法 @BeforeClass 全局只会执行一次，而且是第一个运行 @Before 在测试方法运行之前运行 @Test 测试方法 @After 在测试方法运行之后允许 @AfterClass 全局只会执行一次，而且是最后一个运行 1234567891011121314151617181920212223242526272829public class MathTestTest &#123; @Before public void setUp() throws Exception &#123; System.out.println(&quot;setUp&quot;); &#125; @After public void tearDown() throws Exception &#123; System.out.println(&quot;tearDown&quot;); &#125; @Test public void testAdd() &#123; System.out.println(&quot;add&quot;); &#125; @Test public void testSub() &#123; System.out.println(&quot;sub&quot;); &#125; @BeforeClass public static void beforeOne()&#123; System.out.println(&quot;beforeOne&quot;); &#125; @AfterClass public static void afterOne()&#123; System.out.println(&quot;afterOne&quot;); &#125;&#125; 输出 12345678beforeOnesetUpaddtearDownsetUpsubtearDownafterOne]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存储区域]]></title>
    <url>%2F2018%2F05%2F18%2F%E5%AD%98%E5%82%A8%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Java程序由JVM执行，所以其内存区域划分的时候就是指JVM区域划分。 Java源码文件(.java)编译生成字节码文件（.class），然后由JVM中的类加载器加载各个类的字节码文件，加载完毕之后，交由JVM执行引擎执行。整个程序执行过程中，JVM会用一段空间来存储程序执行期间需要用到的数据和相关信息，这段空间一般被称作Runtime Data Area（运行时数据区），也就是JVM内存。因此，在Java中说到的内存管理就是针对这段空间进行管理。 存储区域寄存器最快的存储区，保存的是程序当前执行的指令地址，执行结束后，自动获取下一天指令，位于CPU处理器内部。数量极其有限，由编译器根据需求进行分配。java中，不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象。 了解：CPU 1.80GHz（Hz是单位）即CPU运算时的工作频率（1秒内发生的同步脉冲数）的简称。从理论上讲CPU的主频越高，它的速度也就越快，因为频率越高，单位时钟周期内完成的指令就越多，从而速度也就越快了. 栈存放基本类型的变量数据和对象的引用。速度仅次于寄存器。创建程序时候，JAVA编译器必须知道存储在栈内所有数据的确切大小和生命周期。当线程执行一个方法时，就会随之创建一个对应的栈帧，即每个方法在执行的同时都会创建一个栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。栈帧：局部变量表，方法返回地址等 堆用来存储所有new出来的对象。关于空间释放，Java的垃圾回收机制会自动进行处理，因此这部分空间也是Java垃圾收集器管理的主要区域。在堆里分配存储有很大的灵活性。当你需要创建一个对象的时候，只需要new，一行简单的代码，当执行这行代码时，会自动在堆里进行存储分配。当然，为这种灵活性必须要付出相应的代价。用堆进行存储分配比用栈进行存储需要更多的时间。另外堆是被所有线程池共享的，在JVM中只有一个堆。当申请不到空间时会抛出 OutOfMemoryError（内存溢出），可使用无限循环不断新建对象，添加到集合中，最终会导致内存溢出. 拓展：内存泄漏主要是一个对象已经不再需要使用，但却被另一个对象持有时，就有可能发生内存泄漏。比如在方法内一个对象被全局的HashMap持有，方法执行结束没有释放就会导致内存泄漏。 注意：在JDK1.6之前，字符串常量池一直放在方法区中，但是到jdk1.7的时候，常量池便被移出方法区，转到Java堆中了 栈与堆的比较 栈(stack)与堆(heap)都是Java用来在Ram（random-access memory）中存放数据的地方。 栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢 。 方法区/静态存储区各个线程共享的区域，存放程序运行时一直存在的数据，存储已被虚拟机加载的每个类的信息（包括类的名称、方法信息、字段信息）静态变量（static修饰的成员变量）、常量、编译器编译后的代码（class文件）等。 常量存储区声明为final的为常量，保存在常量储存区，还有String类型的对象都是常量，系统维护了一个String常量池，常量池存储在方法区中。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类加载]]></title>
    <url>%2F2018%2F05%2F12%2F%E7%B1%BB%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[类加载概述类加载时机 第一次使用某个类时加载 预加载机制来加载 JVM与程序：用Java命令运行某个Java程序时，这个命令会启动一个Java虚拟机进程，这个进程中可能会有很多的线程，但这些线程都处于该Java虚拟机进程中。 JVM进程可能被终止的情况： 程序正常结束 程序运行到使用System.exit()或Runtime.getRuntime().exit()代码处结 程序运行中有未处理的异常或错误 程序所在平台强行结束JVM进程 123public class Demo &#123; public static int a = 10;&#125; 123456public class Test1 &#123; public static void main(String[] args) &#123; Demo.a ++; System.out.println(Demo.a); //结果？ 11 &#125;&#125; 12345public class Test2 &#123; public static void main(String[] args) &#123; System.out.println(Demo.a); //结果？ 10 &#125;&#125; 启动运行是两个JVM进程 程序使用要使用某个类时，如果该类还没有被加载到内存中，则系统会通过下面3个步骤（JVM连续完成）完成类加载或类初始化: 加载 连接 初始化 类的加载类加载：就是把类的class文件读入内存，同时为这个class创建一个java.lang.Class对象（普通类的类） 类：是某一类对象的抽象(概念)，其实类也是一种对象,如: 1Class.forName(driver); 类其实都是java.lang.Class的实例，类的加载由JVM提供的类加载器完成，该加载器通常称为系统类加载器，我们可以通过继承ClassLoader基类来创建自己的类加载器 123public class MyClassLoader extends ClassLoader&#123; …….//自定义类加载逻辑 &#125; 类加载就是把.class文件读入内存 加载类的二进制数据的来源: 本地文件系统加载class文件 从JAR包加载class文件，如JDBC中的驱动就是放在JAR文件中的 通过网络加载class文件 把一个Java源文件动态编译，并加载 类加载器加载器负责将.class文件加载到内存，并为之生成对应的java.lang.Class对象 如果一个类被载入JVM中，同一个类就不会被再次载入了。 JVM启动时，会形成由3个类加载器形成的初始类加载器层次结构: Bootstap ClassLoader:根类加载器,负责加载Java核心类,它很特殊，它不是java.lang.ClassLoader的子类，而是由JVM自身实现的。 Extension ClassLoader:扩展类加载器,负责加载JRE的扩展目录(%JAVA_HOME%/jre/lib/ext或者由java.ext.dirs系统属性指定的目录)中JAR包的类 System ClassLoader:系统类加载器,负责在JVM启动时加载来自java命令的-classpath选项 类的连接类加载–&gt;生成对应的Class对象–&gt;连接(主要负责把加载过来的二进制文件合并到JRE) 连接又分3阶段: 验证:检查加载过来的类是否有正确的结构 准备:为类的静态Field分配内存，并设置默认初始值 解析:把类的二进制数据中的符号引用替换成直接引用 符号引用:以一组符号来描述所引用的目标, 符号可以是任何形式的字面量, 只要使用时能够无歧义的定位到目标即可. 例如, 在Java中, 一个Java类将会编译成一个class文件. 在编译时, Java类并不知道所引用的类的实际地址, 因此只能使用符号引用来代替. 比如org.simple.People类引用了org.simple.Language类, 在编译时People类并不知道Language类的实际内存地址, 因此只能使用符号org.simple.Language来表示Language类的地址. 直接引用:直接指向目标的指针.(如指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针)，相对偏移量. (指向实例的变量, 方法的指针)，一个间接定位到对象的句柄. 如果有了直接引用，那引用的目标必定已经被加载入内存中了。 类的初始化初始化是由JVM负责，主要就是对静态Field进行初始化，静态Field指定初值两种方式: 声明时指定 使用静态初始化块为其赋值 12345678public class Demo &#123; static int a = 10; static int b; static int c; static &#123; b = 20; &#125;&#125; 123456789101112public class Demo &#123; public static int a = 10; static int c; static &#123; b = 20; &#125; // 定义b并为其赋值 static int b = 15; public static void main(String[] args) &#123; System.out.println(b); // 输出？ 15 &#125;&#125; JVM初始化类的步骤: 如果这个类还没有被加载，则先加载并连接该类 如果该类的直接父类还没有被初始化，则先初始化其直接父类 如果该类中有初始化语句，则系统依次执行这些初始化语句 初始化时机 Java程序首次通过下面6种方式来使用某个类或接口时，系统会初始化该类或接口 创建类实例:new 、反射、反序列化 调用类的静态方法 访问某个类或接口的静态Field或为该静态Field赋值 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象如 Class.forName(“Person”),如果Person没有被初始化，则此时会初始化 初始化某个类的子类 直接使用java.exe命令来运行某个主类 对于final修饰的静态Field，如果该Field的值在编译时就可以确定下来，那么这个Field相当于宏变量。这种情况下是不会初始化这个类的,反之如果编译时不能确定，那么就要初始化这个类 类的加载与类的初始化是不同的，类加载不一定初始化，但类初始化之前这个类一定被加载]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exception]]></title>
    <url>%2F2018%2F05%2F10%2FException%2F</url>
    <content type="text"><![CDATA[12345Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero at com.train.day07.ExceptionDemo1.test3(ExceptionDemo1.java:25) at com.train.day07.ExceptionDemo1.test2(ExceptionDemo1.java:18) at com.train.day07.ExceptionDemo1.test1(ExceptionDemo1.java:12) at com.train.day07.ExceptionDemo1.main(ExceptionDemo1.java:6) 错误信息为方法的调用栈信息 main 调用 test1 -&gt;调用test2-》调用test3 在test3中发生异常，再将来检查错误时，从上向下找到自己所写代码第一次出现的位置，点击对应的类，指向的哪一行就是错误抛出的位置，之后根据此行代码，去分析错误。 异常： 运行时异常 RuntimeException，是因为程序员的问题，写代码缺少必要的判断与逻辑，遇到这样的问题，必须要解决，解决的方式，不是try-catch，而是通过修改代码，避免这样的异常 ArithmeticException NullPointerException …… 检查型异常 CheckedException ，写代码的过程，如果需要捕获，程序会提示，否则编译不通过，无法运行 File IO 运行时异常，就是我们所俗称的bug，程序运行的时候抛出的 ArithmeticException 算术异常 运行时异常 NullPointerException 空指针异常 ArraysOutOfBoundsException 数组下表越界]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[范式]]></title>
    <url>%2F2018%2F05%2F07%2F%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[逻辑数据库设计—规范化逻辑模型范式（ Normal form，简称NF ）表示关系模式的级别，是衡量关系模式规范化程度的标准，达到范式的关系才是规范化的。 各种范式之间的联系是：5NF ∈ 4NF ∈ 3NF ∈ 2NF ∈ 1NF 规范化:一个低级范式的关系模式，通过关系模式的投影分解，可以转换为若干个高一级范式的关系模式的集合的过程。实际的关系数据库一般使用3NF以上的关系。 规范化的步骤 将数据库分为两个或更多个表； 定义表之间的关系。 规范化数据库的任务 尽可能减少冗余 减少数据的不一致性 加快数据修改（插入、更新的删除） 第一范式（ R∈1NF ）关系模式R中的所有属性都是不可再分的数据项。 表必须符合的条件 表必须是二维的（用行和列表示） 每个数据库单元只包含一个值 每列必须具有单独的含义 学生表是1NF，职工表不是 第二范式（R∈2NF ）规范化逻辑模型 —转换为第二范式数据模型 关系R∈1NF，且它的每一非主属性都完全依赖于主键。 1它的规则是要求数据表里的所有非主属性都要和该数据表的主键有完全依赖关系；如果有哪些非主属性只和主键的一部份有关的话，它就不符合第二范式。同时可以得出：如果一个数据表的主键只有单一一个字段的话，它就一定符合第二范式(前提是该数据表符合第一范式) 原则 消除实体中的冗余信息 将只依赖于一部分多值主键的属性移到另一个表中 使存储的信息更一致 解决方法 拆分表 示例 考虑一个小学的教务 管理系统，学生上课指定一个老师，一本教材，一个教室，一个时间，大家都上课去吧，没有问题。那么数据库怎么设计？ 学生上课表 12学生 课程 老师 老师职称 教材 教室 上课时间 小明 一年级语文（上） 大宝 副教授 《小学语文1》 101 14：30 12345678一个学生上一门课，一定在特定某个教室。所以有（学生，课程）－&gt;教室一个学生上一门课，一定是特定某个老师教。所以有（学生，课程）－&gt;老师一个学生上一门课，他老师的职称可以确定。所以有（学生，课程）－&gt;老师职称一个学生上一门课，一定是特定某个教材。所以有（学生，课程）－&gt;教材一个学生上一门课，一定在特定时间。所以有（学生，课程）－&gt;上课时间因此（学生，课程）是一个码然而，一个课程，一定指定了某个教材，一年级语文肯定用的是《小学语文1》，那么就有课程－&gt;教材（学生，课程）是个码，课程却决定了教材，这就叫做不完全依赖，或者说部分依赖。出现这样的情况，就不满足第二范式！ 学生上课表新 12课程 教材 学生 课程 老师 老师职称 教室 上课时间 第三范式（ R∈3NF ）规范化逻辑模型 —创建第三范式数据模型 若R∈2NF，且它的每一非主属性都不传递依赖于关键字即消除传递依赖。 1表中有可能存在某些数据元素依赖于其他非关键字数据元素的现象,必须消除 原则 除去所有不依赖某个键值而存在的列 将不直接与实体联系的任何数据都移到另一个表中 避免信息的更新异常和删除异常 确保不含冗余信息 操作步骤 将数据模型规范化为第二范式； 确定不依赖键值而存在的所有属性； 将这些独立的属性都移到各个单独的表中，并为之确定主键。且将这些主键作为外键连接到父实体中。 示例上面的“学生上课表新”符合2NF，但是它有传递依赖！ 1问题就出在“老师”和“老师职称”这里。一个老师一定能确定一个老师职称。 还有什么问题吗？ 老师升级了，变教授了，要改数据库，表中有N条，改了N次……（修改异常） 没人选这个老师的课了，老师的职称也没了记录……（删除异常） 新来一个老师，还没分配教什么课，他的职称记到哪？……（插入异常 那应该怎么解决呢？和上面一样，投影分解： 老师 老师职称 课程 教材 学生 课程 老师 教室 上课时间 数据库设计1.一对一 2.一对多 3.多对多]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Class]]></title>
    <url>%2F2018%2F05%2F01%2FClass%2F</url>
    <content type="text"><![CDATA[instanceof它的作用是测试它左边的对象是否是它右边的类的实例，或者右边的类的子类实例，返回 boolean 的数据类型。 1234567public static void test()&#123; String a = &quot;&quot;; Object obj = new Object(); System.out.println(a instanceof String);// true System.out.println(a instanceof Object);// true System.out.println(obj instanceof String);// false &#125; 内部类我们把一个类放在另一个类的内部定义，这个定义在其他类内部的类就被称为内部类，有的也叫嵌套类，包含内部类的类也被称为外部类有的也叫宿住类。 内部类提供了更好的封装，内部类成员可以直接访问外部类的私有数据，因为内部类被当成其他外部类成员。 12345678910public class InnerClassDemo &#123; // 外部类私有成员 private int a = 10; class Inner&#123; void test()&#123; // 内部类中可直接访问 System.out.println(a); &#125; &#125;&#125; 非静态内部类当在非静态内部类的方法内访问某个变量时，系统优先在该方法内查找是否存在该名字的局部变量，如果存在该名字的局部变量，就使用该变量，如果不存在，则到该方法所在的内部类中查找是否存在该名字的属性，如果存在则使用该属性。 总之，第一步先找局部变量，第二步，内部类的属性，第三步。外部类的属性。 1234567891011121314151617public class InnerClassDemo &#123; // 外部类私有成员 private int a = 10; public static void main(String[] args) &#123; new InnerClassDemo().new Inner().test(); &#125; class Inner&#123; int a = 20; void test()&#123; int a = 30; // 内部类中可直接访问 System.out.println(a); &#125; &#125;&#125; 静态内部类如果用static修饰一个内部类，称为静态内部类。 静态内部类可以包含静态成员，也可以包含非静态成员。所以静态内部类不能访问外部类的实例成员，只能访问外部类的类成员。 静态内部类的对象寄存在外部类里，非静态内部类的对象寄存在外部类实例里 12345678910111213141516171819202122232425262728public class InnerClassDemo &#123; // 外部类私有成员 private int a = 10; public static void main(String[] args) &#123; // 非静态内部类的对象寄存在外部类实例里 new InnerClassDemo().new Inner().test(); // 静态内部类的对象寄存在外部类里 new InnerClassDemo.InnerStatic().test(); &#125; class Inner&#123; int a = 20; void test()&#123; int a = 30; // 内部类中可直接访问 System.out.println(a); &#125; &#125; static class InnerStatic&#123; static int c = 15; int b = 16; void test()&#123; // a为外部类实例成员，访问报错// System.out.println(a); &#125; &#125;&#125; 局部内部类如果把一个内部类放在方法里定义，这就是局部内部类，仅仅在这个方法里有效。 局部内部类不能在外部类以外的地方使用，那么局部内部类也不能使用访部控制符和static修饰 1234567void testInner()&#123; // 将访问修饰符会报错，如private class Inner&#123; &#125; Inner inner = new Inner();&#125; 匿名内部类匿名内部类适合创建那种只需要一次使用的类，定义匿名内部类的语法格式如下： new 父类构造器（抽象类/接口） { ​ //匿名内部类的 类体部分 } 匿名内部类不能是抽象类，匿名内部类不能定义构造器 123456IProduct product = new IProduct()&#123; @Override public String getProduct() &#123; return null; &#125; &#125;; 枚举类J2SE1.5新增了一个enum关键字，用以定义枚举类。正如前面看到，枚举类是一种特殊的类，它一样可以有自己的方法和属性，可以实现一个或者多个接口，也可以定义自己的构造器。 枚举类也是一种类，只是它是一种比较特殊的类，因此它一样可以使用属性和方法 枚举类可以实现一个或多个接口，使用enum定义的枚举类默认继承了java.lang.Enum类，而不是继承Object类(间接继承)。其中java.lang.Enum类实现了java.lang.Serializable和java.lang.Comparable两个接口。 枚举类的构造器只能使用private访问控制符，如果省略了其构造器的访问控制符，则默认使用private修饰；如果强制指定访问控制符，则只能指定private修饰符。 枚举类的所有实例必须在枚举类中显式列出，否则这个枚举类将永远都不能产生实例。列出这些实例时系统会自动添加public static final修饰，无需程序员显式添加。 12345678public enum Animal &#123; PIG,DOG,MONKEY; public int age; private Animal()&#123; &#125;&#125; 所有枚举类都提供了一个values方法，该方法可以很方便地遍历所有的枚举值。 1234567public static void main(String[] args) &#123; Animal[] animals = Animal.values(); for (Animal anim:animals) &#123; System.out.println(anim); System.out.println(anim.age); &#125; &#125; 枚举类通常应该设计成不可变类，也就说它的属性值不应该允许改变，这样会更安全，而且代码更加简洁。为此，我们应该将枚举类的属性都使用private final修饰。 一旦为枚举类显式定义了带参数的构造器，则列出枚举值时也必须对应地传入参数。 12345678public enum Animal &#123; PIG(10),DOG(20),MONKEY(30); private final int age; // 推荐 private Animal(int age)&#123; this.age = age; &#125;&#125; 枚举类也可以实现一个或多个接口。与普通类实现一个或多个接口完全一样，枚举类实现一个或多个接口时，也需要实现该接口所包含的方法。 如果需要每个枚举值在调用同一个方法时呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法，每个枚举值提供不同的实现方式，从而让不同枚举值调用同一个方法时具有不同的行为方式 123public interface EnumInterface &#123; void play();&#125; 1234567891011121314151617181920212223public enum Animal implements EnumInterface&#123; PIG(10)&#123; @Override public void play() &#123; System.out.println(&quot;拱白菜&quot;); &#125; &#125;,DOG(20)&#123; @Override public void play() &#123; System.out.println(&quot;啃骨头&quot;); &#125; &#125;,MONKEY(30); private final int age; private Animal(int age)&#123; this.age = age; &#125; @Override public void play() &#123; System.out.println(&quot;耍&quot;); &#125;&#125; 可以在枚举类里定义一个抽象方法，然后把这个抽象方法交给各枚举值去实现即可。 1234567891011PIG(10)&#123; @Override public void play() &#123; System.out.println(&quot;拱白菜&quot;); &#125; // 类中包含抽象方法，要为每个实例提供相应的实现 @Override public void yelling() &#123; &#125; &#125; 12// 枚举类内部定义 public abstract void yelling(); Object Object类是所有类、数组、枚举类的父类，也就是说，Java允许把所有任何类型的对象赋给Object类型的变量。当定义一个类时没有使用extends关键字为它显式指定父类，则该类默认继承Object父类。 打印对象和toString方法：toString方法是系统将会输出该对象的“自我描述”信息，用以告诉外界对象具有的状态信息。Object 类提供的toString方法总是返回该对象实现类的类名 + @ +hashCode值。 ==和equals比较运算符：==要求两个引用变量指向同一个对象才会返回true。equals方法则允许用户提供自定义的相等规则。 Object类提供的equals方法判断两个对象相等的标准与==完全相同。因此开发者通常需要重写equals方法。 JVM GC]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F2018%2F04%2F30%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式观察者又称为发布订阅模式，是对象的行为模式。观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监视者被观察者的状态，当被观察者的状态发生变化时，会通知所有观察者，并让其自动更新自己。 如：y = x2，y随x的变化而变化 再如：一个商家和一些电商合作，每当有新产品发布时，就会把这些产品推送到电商平台。如纸盒淘宝，京东合作，则有如下伪代码 1234if(产品库中有新产品) &#123; 推送产品到淘宝； 推送产品到京东；&#125; 如果又和当当，苏宁合作，则改变伪代码 123456if(产品库中有新产品) &#123; 推送产品到淘宝； 推送产品到京东； 推送产品到当当; 推送产品到苏宁；&#125; 一次类推，若还有商家加入，则需要再次改动代码，当多达百家时，将非常复杂。另外考虑推送中异常的发生，代码会堆砌过多，维护困难。现实中对开发团队而言，可能产品时产品团队维护，而合作的电视又是电商团队在维护，两个团队维护同一功能代码，显然会造成责任不清的问题。 观察者模式责任清晰，易于扩展。首先，把每一个电商接口看成一个观察者，每一个观察者都能观察到产品列表（被监听对象）。当公司发布新产品时，就会发送到这个产品列表上。于是产品列表就发生了变化，这是可以触发各个电商接口（观察者）发送新产品到对应的合作电商那里。 类似这样，一个对象（电商接口）去监听另一个对象（产品列表），当被监听对象发生变化时，电商接口就会出发一定的行为，以适应变化的逻辑模式，我们成为观察者模式，电商接口被称为观察者或者监听者，而产品列表被称为被观察者或者被监听对象。 。。。 好处在于，程序中不再出现if语句，观察者会根据观察对象的变化而做出对应的行为。无论时淘宝，京东以及其他电商接口只要维护自己的逻辑，而无需耦合在一起。同时责任也是明确的，产品团队只要负责产品列表，电商团队可以通过增加观察者去监听产品的电商接口，不会带来if语句导致的责任不明的情况。]]></content>
      <categories>
        <category>JAVA模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂模式]]></title>
    <url>%2F2018%2F04%2F30%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式大部分情况下，我们new关键字来创建对象。举例来说，现实中车子的种类可能很多，有大巴车，轿车，救护车，越野车，卡车等，每个种类下面还有具体的型号，一个工厂生产如此多的车难以管理，所以还需要进一步拆分为各个分工厂：大巴车，轿车等分工厂。但是客户不需要知道工厂是如何拆分的，只会告诉客服需要什么车，客服会根据客户的需要找到对应的工厂去生产车。对客户而言，车厂只是一个抽象概念，只是知道有这样的一个工厂能满足他的需要。 普通工厂模式有个IProduct的产品接口，其下有5个实现类，Product1，Product2，Product3，Product4，Product5。他们属于一个大类，可以通过一个工厂去管理他们的生成。但是由于类型不同，所以初始化有所不同。为了方便使用产品工厂（ProductFactory）类来创建这些产品的对象，用户可以通过产品号来确定需要哪种产品。 123public interface IProduct &#123; String getProduct();&#125; 123456public class Product1 implements IProduct&#123; @Override public String getProduct() &#123; return &quot;产品1&quot;; &#125;&#125; 1234567public class Product2 implements IProduct&#123; @Override public String getProduct() &#123; return &quot;产品2&quot;; &#125;&#125; 123456public class Product3 implements IProduct&#123; @Override public String getProduct() &#123; return &quot;产品3&quot;; &#125;&#125; 1234567891011121314public class ProductFactory &#123; public static IProduct createProduct(String productNum)&#123; switch(productNum)&#123; case &quot;1&quot;: return new Product1(); case &quot;2&quot;: return new Product2(); case &quot;3&quot;: return new Product3(); default: throw new RuntimeException(&quot;未知产品&quot;); &#125; &#125;&#125; 12345678public class Main &#123; public static void main(String[] args) &#123; // 需要哪种产品，直接传入对应的产品号即可 IProduct product = ProductFactory.createProduct(&quot;2&quot;); String info = product.getProduct(); System.out.println(info); &#125;&#125; 抽象工厂模式抽象工厂模式可以向客户端提供一个接口，客户在不必指定产品的具体情况下创建多个产品族中的产品对象。 对于普通工厂而言，他解决了一类对象创建问题，但是有时候对象很复杂，有几十个有分为几个类别。如果只有一个工厂，面对如此多的产品，这个工厂需要实现的逻辑就复杂了，所以希望把工厂分成好几个。这样便于工厂产品规则的维护，但是设计者不想让调用者知道具体的工厂规则，而只是希望他们知道一个统一的工厂即可。这样设计有助于对外封装和简化调用者的使用，毕竟调用者也不想知道选择具体工厂的规则。 以车厂为例，生产商不会把轿车，大巴车，吉普车等车型都放在一个车厂生产，那样会导致车厂异常复杂，导致管理和维护。所以生产商通常会把这些分为轿车厂，大巴车厂，警车厂等分厂。么个种类下面有一些型号的产品。但对于客户而言，只要告诉客服需要什么车即可。后续交给客服分配即可。 客户只是认为有一个能够生产各类车的工厂，他能生成所需要的产品，这里工厂只是一个虚拟的概念，并不真实存在，他是通过车厂内部各个分厂实现的，这个虚拟工厂称为抽象工厂。各个分厂称为具体工厂。为了统一，需要制定一个接口规范（IProductFactory），所有的具体工厂和抽象工厂都要实现这个接口，IProductFactory接口设计成。 123public interface IProductFactory &#123; IProduct createProduct(String proNo);&#125; 调用者不用理会ProductFactory不需要去理会ProductFactory选择使用哪个具体工厂的规则。对于设计者而言ProductFactory就是一个抽象工厂，每一个工厂只需要维护其类型产品对象的生成，具体的工厂规则也不会特别复杂，难以维护。]]></content>
      <categories>
        <category>JAVA模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型]]></title>
    <url>%2F2018%2F04%2F26%2F%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[方法参数：定义方法时有形参，调用方法时传递实参。 泛型，即“参数化类型”，即将类型由原来具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array排序]]></title>
    <url>%2F2018%2F04%2F26%2FArray%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[Array异常123456789101112131415161718static String[] sArr; public static void main(String[] args) &#123; int[] iArr = new int[4]; // 数组下标从0开始，最大值 长度-1 3 System.out.println(iArr.length); System.out.println(iArr.length-1); // 数组通过下标访问 System.out.println(iArr[1]); // ArrayIndexOutOfBoundsException (异常): 4（越界的位置） // at ......ArrException.main(ArrException.java:12) 在哪个类.哪个方法 哪一行代码 // 没讲异常怎么处理之前，一旦发生异常，程序就会终止 // System.out.println(iArr[4]); // lang.NullPointerException 运行时异常，俗称的BUG System.out.println(sArr.length); &#125; 带有随机数1234567891011121314151617public static void main(String[] args) &#123; // 整型数组，长度为5，为给他们依次赋值[0,100],之间的随机数 int[] iArr = new int[5]; for (int i = 0; i &lt; iArr.length; i++) &#123; // [0.0,1.0)-&gt;[0.0,101) double int score = (int)(Math.random() * 101); iArr[i] = score; &#125; // [0.0,1.0)-&gt; [0.0,80] + 20 -&gt;[20.0,100] // Math.random() * 81 + 20 System.out.println(&quot;===========&quot;); // 数组中元素的类型 变量接收遍历得到的元素:数组 for (int x:iArr) &#123; System.out.println(x); &#125; &#125; 练习1234567891011121314151617public static void main(String[] args) &#123; String[] sArr = &#123;&quot;公孙离&quot;,&quot;孙悟空&quot;,&quot;达摩&quot;,&quot;黄忠&quot;,&quot;妲己&quot;&#125;; String[] sArr1 = new String[3]; // 随机产生sArr的下标，将对应下标的值赋值给sArr1(产生3次赋值3次) // ，输出sArr1 for (int i = 0; i &lt;sArr1.length; i++) &#123; int index = (int)(Math.random() * sArr.length); sArr1[i] = sArr[index]; &#125; for (int i = 0; i &lt; sArr1.length; i++) &#123; System.out.println(sArr1[i]); &#125; for (String hero:sArr1 ) &#123; System.out.println(hero); &#125; &#125; 求最大值1234567891011121314151617181920212223public static void main(String[] args) &#123; // 随机产生一个5个元素的整型数组，求该数组中的最大值 [30-120] int[] iArr = new int[5]; for (int i = 0; i &lt; iArr.length; i++) &#123; int data =(int) (Math.random() * 91) + 30; iArr[i] = data; &#125; for (int x:iArr) &#123; System.out.print(x + &quot; &quot;); &#125; System.out.println(); // 假设第一个是最大值，那这个值跟数组中其他的元素进行比较 // 如果大于他，将这个大的值覆盖原最大值 int maxValue = iArr[0]; for (int i = 1; i &lt; iArr.length; i++) &#123; if (maxValue &lt; iArr[i])&#123; maxValue = iArr[i]; &#125; &#125; System.out.println(maxValue); &#125; 二分查找在一个有序数组中查找某个元素是否存在 数组 arr：最大小标 最小下标 （lowIndex + uperIndex）/ 2 -&gt; middleIndex arr[middleIndex] 与待查找元素进行比较，如果大于，说明在middleIndex的左边 ​ 如果小于，说明在middleIndex的右边 重新调整lowIndex 或 uperIndex -》middleIndex 在进行比较 如果找到了，条件是什么 如果没找到，条件又是什么 135 40 48 86 95 123456789101112131415161718192021222324252627282930static int[] iArr = &#123;12,33,38,49,50,66&#125;; public static void main(String[] args) &#123; binarySearch(); &#125; public static void binarySearch()&#123; Scanner scanner = new Scanner(System.in); int value = scanner.nextInt(); int lowIndex = 0; int upperIndex = iArr.length - 1; int middleIndex = 0; while(lowIndex &lt;= upperIndex)&#123; // 出口条件控制 middleIndex = (lowIndex + upperIndex) / 2; if(iArr[middleIndex] == value)&#123; System.out.println(middleIndex); break; &#125; else if(iArr[middleIndex] &gt; value)&#123; upperIndex = middleIndex-1; &#125; else &#123; lowIndex = middleIndex + 1; &#125; &#125; if(lowIndex &gt; upperIndex) &#123; // 怎样判断没有找到 System.out.println(&quot;没有找到&quot;); &#125; &#125; 冒泡排序从小到大排序，两两比较，如果前面的大于后面，就交换他们的位置，经过多轮比较之间，实现从小到大 1234548 95 35 86 40 48 35 86 40 9535 48 40 86 9535 40 48 86 9535 40 48 86 95 123456789101112131415161718static int[] iArr = &#123;48,95,35,86,40&#125;; public static void main(String[] args) &#123; for (int i = 0 ; i &lt; iArr.length-1; i ++) &#123; for (int j = 0; j &lt; iArr.length - i - 1; j++) &#123; if(iArr[j] &gt; iArr[j+1])&#123; // 交换两个元素的位置，需要引入第三个变量 int temp = iArr[j]; iArr[j] = iArr[j+1]; iArr[j+1] = temp; &#125; &#125; &#125; for (int x:iArr) &#123; System.out.println(x); &#125; &#125; 改良的冒泡排序-》快速排序 选择排序123448,95,35,86,40-&gt;35,95,48,86,4035,95,48,86,40-&gt;35,48,95,86,40-&gt;35 40 95 86 4835 40 95 86 48-&gt;35 40 86 95 48 -&gt;35 40 48 86 95 35 40 48 86 95 -&gt; 12345678910111213141516static int[] iArr = &#123;48,95,35,86,40&#125;; public static void main(String[] args) &#123; for (int i = 0; i &lt; iArr.length-1; i++) &#123; for (int j = i; j &lt; iArr.length; j++) &#123; if(iArr[i] &gt; iArr[j])&#123; int temp = iArr[i]; iArr[i] = iArr[j]; iArr[j] = temp; &#125; &#125; &#125; for (int x:iArr) &#123; System.out.println(x); &#125; &#125; Arrays12345678910111213static int[] iArr = &#123;32,34,12,2,11,22,45&#125;; public static void main(String[] args) &#123; // ascending升序 desc降序 Arrays.sort(iArr); for (int x:iArr) &#123; System.out.println(x); &#125; // 返回大于等于0,表示查找到了数据，否则没有找到 int index = Arrays.binarySearch(iArr, 32); System.out.println(index); &#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[循环结构&&条件语句]]></title>
    <url>%2F2018%2F04%2F21%2F%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[switch-case-breakSwitch-case-break 1、使用break语句，防止case穿透 2、 default可以省略，但不推荐省略 3、 switch语句中控制表达式的类型只能是byte、short、char、int、String（JDK7新增）和枚举 123456789101112131415161718192021222324252627282930313233public static void main(String[] args) &#123; // 从键盘接收输入，一串字符串 // 如果输入的是篮球，输出，爱好是篮球 // 如果输入的是足球，输出，爱好是足球 // 如果输入的是网球，输出，爱好是网球 // 如果输入的不是上述信息，输出输入不合法 // default:如果输入的信息都没有出现在case中，则为default // break:跳出switch语句 Scanner scanner = new Scanner(System.in); // 接收键盘输入的字符串 ctrl + q String hobby = scanner.nextLine(); // 开关 选择 byte、short、char、int、String（JDK7新增）和枚举 switch (hobby)&#123; case &quot;篮球&quot;: case &quot;乒乓球&quot;: System.out.println(&quot;爱好是篮球或乒乓球&quot;); break; // 如果没有break,case语句穿透 // 可以出现在switch的任何位置，执行不会受到影响 default: System.out.println(&quot;输入不合法&quot;); break; case &quot;足球&quot;: System.out.println(&quot;爱好是足球&quot;); break; case &quot;网球&quot;: System.out.println(&quot;爱好是网球&quot;); break; &#125; &#125; 引用类型处理基本数据类型，都是引用类型 引用类型，使用==比较两个值是否相等，比较的是存储地址是否相等 只要是new（新建）出来的东西，一定会在堆中（heap）重新开辟空间来存储其数据 1String word2 = new String(&quot;Everyone,there is a world, quiet and lonely there live something!&quot;); 123// 后面的字符串是一个常量，String是不可变的，常量存储在常量去，可以共用String word = &quot;Everyone,there is a world, quiet and lonely there live something!&quot;;String word1 = &quot;Everyone,there is a world, quiet and lonely there live something!&quot;; 实例代码 1234567891011121314151617181920public static void main(String[] args) &#123; String word = &quot;Everyone,there is a world, quiet and lonely there live something!&quot;; String word1 = &quot;Everyone,there is a world, quiet and lonely there live something!&quot;; String word2 = new String(&quot;Everyone,there is a world, quiet and lonely there live something!&quot;); System.out.println(word); System.out.println(word2); System.out.println(word == word1); System.out.println(word == word2); // 不管存储在什么方法，都可以轻松判断值是否相同，这个方法就是equals方法 // 比较两个引用类型的变量值是否相同，使用equals方法，后面涉及到对象时， // 会涉及到重写equals方法 System.out.println(word.equals(word2));// int a = 10;// int b = 20;// System.out.println(a == b); // 字符串分割 // 字符串截取 // 查找 &#125; String的equals方法实现 12345678910111213141516171819202122232425262728293031word.equals(word2)word2 - 传递给 》 anObjectpublic boolean equals(Object anObject) &#123; // == 比较的是地址，如果地址相同，那么值一定相同 if (this == anObject) &#123; return true; &#125; // instanceof判断anObject是否是String类型的 if (anObject instanceof String) &#123; // 将anObject从Object类型转换到String类型 // 赋值给anotherString String anotherString = (String)anObject; // word =转换成字符数组=&gt; value,得到word的长度 int n = value.length; // 判断两个比较的字符串长度是否相等 if (n == anotherString.value.length) &#123; char v1[] = value;// &#123;&apos;E&apos;,&apos;v&apos;,&apos;e&apos;,&apos;r&apos;,&apos;y&apos;&#125; // &#123;&apos;E&apos;,&apos;v&apos;,&apos;e&apos;,&apos;r&apos;,&apos;y&apos;&#125; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; String 字符串 类 / 对象/实例 do-while与while的区别 do-while至少会执行循环一次，先循环，再判断 while 先判断 再循环 123456789101112public static void main(String[] args) &#123; int i = 10; // 先判断后执行 while(i &lt; 10)&#123; System.out.println(&quot;while&quot; + i); &#125; // 先执行 后判断 do&#123; System.out.println(&quot;do-while &quot; + i); &#125; while (i &lt; 10); &#125; 注意：不管是什么循环，一定要给一个出口条件，否则产生死循环，对程序造成是毁灭性的打击。 嵌套for循环12345678910111213141516public static void main(String[] args) &#123; /*int i = 0; for( ; i &lt; 10; i ++) &#123; &#125; System.out.println(i);*/ ///for(;;)&#123;&#125; // 死循环 // 99乘法表 for(int j = 1; j &lt;= 9; j++) &#123; for(int i = 1; i &lt;= j; i++)&#123; System.out.print(i + &quot; * &quot; + j + &quot; = &quot; + (i * j) + &quot;\t&quot;); &#125; System.out.println(); &#125; &#125; return-break-continuereturn返回 - 结束方法 12345678910111213141516171819202122232425262728293031323334353637public static void main(String[] args) &#123; test(); test1(); String content = test2(); System.out.println(content); &#125; public static void test()&#123; String word = &quot;天下风云出我辈，一入江湖岁月催。皇图霸业谈笑中，不胜人生一场醉。&quot;; System.out.println(word); // 结束方法，其后不能再写代码 return; &#125; // void 无返回值 public static void test1()&#123; String word = &quot;天下风云出我辈，一入江湖岁月催。皇图霸业谈笑中，不胜人生一场醉。&quot;; System.out.println(word); // 结束方法，其后不能再写代码 if(word.equals(&quot;天下风云出我辈，一入江湖岁月催。皇图霸业谈笑中，不胜人生一场醉。&quot;)) &#123; // 结束方法 return; &#125; System.out.println(&quot;return之后代码&quot;); &#125; // String 方法的返回值必须是一个String类型的内容 // 必须要有return返回 public static String test2()&#123; String word = &quot;天下风云出我辈，一入江湖岁月催。皇图霸业谈笑中，不胜人生一场醉。&quot;; System.out.println(word); // 结束方法，其后不能再写代码 if(word.equals(&quot;天下风云出我辈，一入江湖岁月催。皇图霸业谈笑中，不胜人生一场醉。&quot;)) &#123; // 结束方法 return &quot;abc&quot;; // 返回到方法调用的地方 &#125; System.out.println(&quot;return之后代码&quot;); return &quot;aaa&quot;;// 返回到方法调用的地方 &#125; break123456789101112131415161718192021222324252627282930313233// break public static void main(String[] args) &#123; int x = 10; switch (x)&#123; case 1: break; // 跳出switch语句，防止case语句穿透 default: break; &#125; //循环里面的break for (int i = 0; i &lt; 10; i ++) &#123; if (i == 5)&#123; break;// 跳出所在的循环 &#125; System.out.println(i); &#125; System.out.println(&quot;break 跳出来执行此处&quot;); for(int i = 0; i &lt; 3; i ++)&#123; for(int j = 0; j &lt; 4; j ++)&#123; if(j == 2)&#123; break; &#125; System.out.println(j); &#125; &#125; boolean isRunning = true; while(isRunning) &#123;// break; isRunning = false; &#125; &#125; continue1234567for (int i = 0; i &lt; 10; i++) &#123; if(i == 5) &#123; continue; // 跳过本次循环，其后的循环代码不在执行 &#125; System.out.println(i); &#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java]]></title>
    <url>%2F2018%2F04%2F19%2FJava%2F</url>
    <content type="text"><![CDATA[[TOC] 环境配置Java​ 两个路径 JDK D:/Java/Jdk1.8.112 Java Development Kit java开发工具包 JRE D:/Java/Jre Java Runtime Enviroment Java运行环境 ​ 后续web中可能会遇到问题，如果将jre装到jdk中 WIN + d 回到桌面 WIN + e 打开文件资源管理器 WIN + R 打开运行窗口 win+e-》这台电脑/桌面上我的电脑 -》 右击 -》 左边有个高级系统设置-》环境变量 -》 系统变量-》新建-》变量名: -》确定 123456**测试**win + r -&gt;输入cmd-》出来窗口中输入 **java** C:\Users\86137&gt;java用法: java [-options] class [args…] (执行类) 或 java [-options] -jar jarfile [args…] (执行 jar 文件)其中选项包括: -d32 使用 32 位数据模型 (如果可用) -d64 使用 64 位数据模型 (如果可用) -server 选择 “server” VM 默认 VM 是 server. -cp &lt;目录和 zip/jar 文件的类搜索路径&gt; -classpath &lt;目录和 zip/jar 文件的类搜索路径&gt; 用 ; 分隔的目录, JAR 档案 和 ZIP 档案列表, 用于搜索类文件。 -D&lt;名称&gt;=&lt;值&gt; 设置系统属性 -verbose:[class|gc|jni] 启用详细输出 -version 输出产品版本并退出12**javac** C:\Users\86137&gt;javac用法: javac 其中, 可能的选项包括: -g 生成所有调试信息 -g:none 不生成任何调试信息 -g:{lines,vars,source} 只生成某些调试信息 -nowarn 不生成任何警告 -verbose 输出有关编译器正在执行的操作的消息 -deprecation 输出使用已过时的 API 的源位置 -classpath &lt;路径&gt; 指定查找用户类文件和注释处理程序的位置 -cp &lt;路径&gt; 指定查找用户类文件和注释处理程序的位置 -sourcepath &lt;路径&gt; 指定查找输入源文件的位置 -bootclasspath &lt;路径&gt; 覆盖引导类文件的位置 -extdirs &lt;目录&gt; 覆盖所安装扩展的位置 -endorseddirs &lt;目录&gt; 覆盖签名的标准路径的位置 -proc:{none,only} 控制是否执行注释处理和/或编译。 -processor [,,…] 要运行的注释处理程序的名称; 绕过默认的搜索进程 -processorpath &lt;路径&gt; 指定查找注释处理程序的位置 12**java -version** C:\Users\86137&gt;java -versionjava version “1.8.0_202”Java(TM) SE Runtime Environment (build 1.8.0_202-b08)Java HotSpot(TM) 64-Bit Server VM (build 25.202-b08, mixed mode) 1234567891011121314151617181920212223242526272829303132333435363738注意：**每修改一次环境变量，需要打开一个新的命令行窗口测试**## Idea Eclipse集成开发环境IDEA 32位 64位都可以安装， 64位选择64位启动的快捷方式（Launcher）## JVM Java virtual machine java虚拟机，保证跨平台,平台无关性,一次编译，多个平台都可以运行。![](C:/Users/NiGulas/Desktop/essay/img/day01-01.png)Java文件 -&gt; 编译生成class文件（字节码文件，二进制文件）-》加载到JVM中运行JVM - Windows - Mac- Linux每个操作系统中安装JVM后，都可以加载class文件执行，Java具有跨平台特性，一次编译，多处运行## GCGarbage collection垃圾回收机制, C,C++,free delete需要手动调用，释放存储空间/对象/连接池---内存资源Java里面垃圾（资源）自动回收，垃圾资源即时置空=null Student stu = new Student(); 创建了一个对象，需要分配空间stu = null; 回收的前提，这样之后会根据JVM内部的垃圾回收算法，当达到一定条件开始回收这些资源 12345678910## IDEA 开发src ：源代码目录，今后写代码都在src中写src-》右击-》new-》Java class**psvm** -&gt; 生成main方法java应用程序的入口，如果要执行这个java文件，一定是从这个main方法开始执行 public static void main(String[] args) { } 12**sout** System.out.println(); 12 System.out.println(“Hello World”); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586## 改编码GBK 国标码UTF-8 万国码 国际通用编码编码不一致会导致乱码File -&gt; Settings -&gt; Project Encoding / Default Encoding for .....## 包package大学院 - 系 - 班Java项目 -》 Java文件成千上万个-》想找某一个文件就有困难-》分包管理后期：service dao pojo/bean contrller ........每个包中放跟这个包名关系密切的相关文件按天分包 -》 包怎么命名-》 域名倒置域名？ baidu.com sina.com -&gt; com.baidu实际工作中，项目的命名 com.baidu.ai.car.项目模块src-&gt;右击-》new-》package-》com.train.day01## 标识符作用：用来起名字-》变量 方法名 类名 ......规则：由字母、数字、下划线，美元符$组成，且数字不能作为开头abc -》 是 1abc-》不是 java中命名规则：- 类名：由有意义的单词组成，并且每个单词的首字母都要大写，如：HelloWorld OrderInfo（大驼峰）- 变量名：由有意义的单词组成，第一个单词的首字母小写，其后遇到的每个单词的首字母大写，如orderList，userOrderInfo- 方法名：同变量名**注意** 优雅的代码 UGLY的代码 ，运算符号，如果 + - =，两边加上空格## 变量写代码，一定会涉及到数据的计算，存储，保存在变量里。java是一种强类型的语言：什么类型的变量，装载什么类型的数据语句的结束，使用分号 ;### 局部变量定义方法内的变量，方法后的```&#123;```开始，到```&#125;```结束，都是属于这个方法的范围作用域：他所处的方法内，也就是最近的```&#123; ```到``&#125; ``结束注意：**局部变量在使用前必须先初始化，初始化就是给它赋值**### 全局变量/成员变量定义在类的```&#123; &#125;```之间的作用域：整个类中都可以访问注意：**在包含static 的方法中，类的加载，先加载 静态成员 在加载非静态成员，带有static修饰的就是静态成员**全局变量与局部变量重名的情况下，优先使用局部变量，**就近原则**## 基本数据类型8种，字母全部小写 byte short int long float double boolean char 1 2 4 8 4 8 1 2 byte short int long 整数 float double 浮点数/小数 boolean true / flase char 字符 表数范围 浮点数带有幂次方位 12### 默认值 public class BasicDataType { static int iVal; // 0 整数都是0 static double dVal; // 0.0 浮点数都是0.0 static boolean bVal; // false static char cVal; // 空白（啥也没有） public static void main(String[] args) { // 局部变量在使用前必须先初始化，初始化就是给它赋值 // 优雅的代码 UGLY的代码 // ctrl + d 复制上面一行代码到下面一行 // ctrl + y 删除一行 System.out.println(iVal); System.out.println(dVal); System.out.println(bVal); System.out.println(cVal); }} 12## float与long float f = 14.5f;// 不加L的情况下，默认是int类型的，当超出int类型的表数范围时就会报错// 故我们在声明long类型的数据时，都要给他加上L，推荐使用大写的L，小写的容易混淆long l = 100000000000L; 1234### 类型转换**自动转换** // 100 默认是int类型，java是一种强类型的语言，类型与变量要一致// 将100自动转换为long类型，再赋值给x// 为什么能够自动转换？long类型的表数范围大于int类型long x = 100; 12**强制转换** double money = 12000.99;// 12000.99-&gt;12000 精度丢失// alt + enter 表数范围大的赋值给表数范围小的int money1 = (int) money; 12345678910111213141516171819202122## 引用类型## 运算符算术运算符：+ , -, * / ,% ,++ ,-- // 自定义方法，方法名op1 // 方法只有被调用，才会执行 public static void op1(){ int a = 100; int b = 3; double c = 3.0; // 整数 除 整数 还是整数 System.out.println(a/b); // 除数 与 被除数，只要有一个是小数，结果就是小数 System.out.println(a/c); // % 取余 100%3=1 System.out.println(a % b); } 12 public static void op2(){ int a = 10; int b = 10; // ++ 在后 10 先执行，后运算（a = a + 1） // a++ =&gt; a = a + 1 System.out.println(a++); // ++ 在前 11 先运算，后执行 System.out.println(++b); } 1234赋值运算符=、+=、*=、/=、%=; a += 5 =&gt; a = a + 5 1234567891011121314位运算符：&amp;、 |、 ~ 、^、 &lt;&lt; 、&gt;&gt;、 &gt;&gt;&gt; 二进制位运算比较运算符&lt;、&gt;、&gt;=、&lt;=、!=（不等于）、==（判断两个值是否相等）逻辑运算符&amp;&amp;、 || 、!、 ^（异或）短路原则：通过第一个已经可以确定结果，就不用再判断第二个了（&amp;&amp; ||） public static void op3(){ // (5&gt;3) true (6&lt;4) false // true &amp;&amp; false =&gt; false // &amp;&amp; 前后两边都为true时，才为true，其他全为false System.out.println( (5&gt;3) &amp;&amp; (6&lt;4)); // true || false =&gt; true // || 前后两边只要有一个为true时，就为true System.out.println( (5&gt;3) || (6&lt;4)); // ! 非true即false 非false即true System.out.println( !(5&gt;3) ); // ^ // 两边不同时为true System.out.println( (5&gt;3) ^ (6&gt;8)); } 1234三目运算符 条件? true的取值 : false 的取值 public static void op4(){ int score = 90; // 条件 ？结果1 : 结果2 // 条件-》true =》结果1 // 条件-》false =》结果2 System.out.println((score &gt;95) ? “优秀” :”一般”); } 1234优先级,,,尽量用小括号,,引起,这样**可读性更好**## IF语句 if 条件{ if语句块} 12 if 条件{ //true} else { // false} 12 if 条件1{ } else if 条件2{ // 条件2 为真，后续条件3与else不会在执行} else if 条件3{ } else { }….. 1234## While不确定循环次数的，适用于while循环 public static void whileDemo(){ boolean isRunning = true; // 创建Scanner对象，用于接收键盘输入 // 开始接收键盘输入，必须输入内容后，代码才能向后执行 // nextInt 表示输入的是一个整数 // 将输入的一个整数赋值给score Scanner scanner = new Scanner(System.in); while(isRunning) { System.out.println(&quot;请输入0-100之间的整数，输入-1退出&quot;); int score = scanner.nextInt(); if(score == -1) { isRunning = false; } else if(score &lt; 60) { System.out.println(&quot;不及格&quot;); } else if(score &gt;= 60 &amp;&amp; score &lt;75) { System.out.println(&quot;及格&quot;); } else if(score &gt;= 75 &amp;&amp; score &lt; 90) { System.out.println(&quot;良好&quot;); } else if(score &gt;= 90 &amp;&amp; score &lt;= 100){ System.out.println(&quot;优秀&quot;); } else { System.out.println(&quot;输入数据不在区间内&quot;); } } }1234## for确定循环次数的，适用于for循环 // 0 - 100的和 public static void main(String[] args) { int sum = 0; // 和的初始值 // fori // i = 0=&gt;0&lt;100 =&gt; 执行循环sum = 0 + 0 = 0 // i++ =&gt; i=1 =&gt; 1 &lt; 100 =&gt; 执行循环sum = 0 + 1 = 1 // i++ =&gt; i=2 =&gt; 2&lt; 100 =&gt; 执行循环sum = 1 + 2 = 3 // for (int i = 0; i &lt;= 100; i++) { sum = sum + i; } System.out.println(sum); } ``` 作业1、求1-100所有整数的的和（多思考） 2、输出100以内的素数 3、输出9x9的乘法表 4、猜数游戏：随机生成一个数，然后让用户从键盘读入这个数，提示用户猜大了还是猜小了，直到猜中 5、编写一个Java应用程序。用户从键盘输入一个1—9999之间的数，程序将判断这个数是几位数，并判断这个数是否是回文数。回文数是指将该数含有的数字逆序排列后得到的数和原数相同，例如12121、3223都是回文数]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown基本语法]]></title>
    <url>%2F2018%2F03%2F12%2FMarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown 是什么？ Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者 HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 Markdown的基本语法标题命令 : #+空格+标题内容 例子: 1# 标题H1## 标题H2### 标题H3#### 标题H4##### 标题H5###### 标题H6 效果： 命令： 斜体：+内容+ 粗体：** + 内容 +** 即粗体又斜体：** + 内容 +** 删除线：+内容+ 例子： 1*我是斜体***我是粗体** ***我是粗斜体***~~我是被删除的~~ 效果： 我是斜体我是粗体我是粗斜体我是被删除的 引用命令： 单行引用：&gt; + 空格 + 内容 多行引用：&gt; + 空格 + 内容 嵌套引用：&gt;+ 空格 +第一层内容 | &gt;&gt;+ 空格 +第二层内容 ，，， 例子： 1单行：&gt; 春风得意马蹄疾，一日看尽长安花多行：&gt; 在天愿作比翼鸟，在地愿为连理枝。 天长地久有时尽，此恨绵绵无绝期。嵌套：&gt; 子曰 &gt;&gt; 学而时习之，不亦说乎？有朋自远方来，不亦乐乎？ 效果： 单行： 春风得意马蹄疾，一日看尽长安花 多行： 在天愿作比翼鸟，在地愿为连理枝。天长地久有时尽，此恨绵绵无绝期。 嵌套： 子曰 学而时习之，不亦说乎？有朋自远方来，不亦乐乎？ 列表命令： 无序列表：*或者+或者- + 空格 + 内容 有序列表：数字 + . +内容 嵌套列表：*或者+或者- 数目增加 例子： 1无序列表： 第一种：+ + A + B + C 第二种：* * A * B * C 第三种：- - A - B - C 有序列表： 1. 第一个 2. 第二个 3. 第三个嵌套列表： - 水果 -- 香蕉 -- 苹果 - 蔬菜 -- 萝卜 -- 白菜 - 面食 -- 馒头 -- 面条 -- 大米 效果： 无序列表： A B C 有序列表： 第一个 第二个 第三个 嵌套列表： 水果。香蕉 。苹果 蔬菜。萝卜。白菜 面食 。馒头。面条。大米 超链接命令： 行内式：[链接文字](地址+ 空格 + 标题) 参考式：两部分组成： 1，链接部分：[链接文字][链接地址] 2，链接地址：[链接标记]:+链接地址+空格+鼠标移动上去的提示文字 图片链接：![链接文字](图片地址+ 空格 + 鼠标移动上去的提示文字) 例子： 1行内式：[百度首页](https://www.baidu.com/ &quot;跳转到百度首页&quot;)参考式：推荐几个网站分别是[GitHub][1]，[百度][2]，[哔哩哔哩][3]。[1]:https://github.com &quot;github.com&quot; &quot;github&quot;[2]:https://www.baidu.com/ &quot;百度一下&quot;[3]:https://www.bilibili.com/ &quot;哔哩哔哩&quot;图片链接：![动漫图片一张](http://qiniuyun.zouyuhang.club/1.jpg) 效果： 行内式：百度首页 参考式：推荐几个网站分别是GitHub，百度，哔哩哔哩。 代码命令： 单行代码 ：+ 单行代码内容 + 多行代码： \ 1多行代码内容 + ```**例子：**~~~c//单行代码``int x = 0;``//多行代码 int a = 0; a++; 1~~~**效果：**单行代码:``int x = 0;``多行代码：```c int a = 0; a++; 表格命令： 使用| 来分隔不同的单元格，使用-来分隔表头和其他行。 在表头下方的分隔线---标记中加入:，即可指定对齐方式。 :---代表左对齐。 :---: 代表居中对齐。 ---:代表右对齐。 例子： 1姓名 | 年龄--- | ---数学 | 18历史 | 19语文 | 20物理 | 21 效果： 姓名 年龄 数学 18 历史 19 语文 20 物理 21]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F02%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
